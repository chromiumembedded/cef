// Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// A portion of this file was generated by the CEF translator tool.  When
// making changes by hand only do so within the body of existing function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//

#include "libcef_dll/cpptoc/stream_reader_cpptoc.h"
#include "libcef_dll/cpptoc/xml_reader_cpptoc.h"


// GLOBAL FUNCTIONS - Body may be edited by hand.

CEF_EXPORT cef_xml_reader_t* cef_xml_reader_create(cef_stream_reader_t* stream,
    enum cef_xml_encoding_type_t encodingType, const cef_string_t* URI)
{
  CefRefPtr<CefXmlReader> impl = CefXmlReader::Create(
      CefStreamReaderCppToC::Unwrap(stream), encodingType, CefString(URI));
  if(impl.get())
    return CefXmlReaderCppToC::Wrap(impl);
  return NULL;
}


// MEMBER FUNCTIONS - Body may be edited by hand.

int CEF_CALLBACK xml_reader_move_to_next_node(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToNextNode();
}

int CEF_CALLBACK xml_reader_close(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->Close();
}

int CEF_CALLBACK xml_reader_has_error(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->HasError();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_error(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetError();
  return retStr.DetachToUserFree();
}

enum cef_xml_node_type_t CEF_CALLBACK xml_reader_get_type(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return XML_NODE_UNSUPPORTED;

  return CefXmlReaderCppToC::Get(self)->GetType();
}

int CEF_CALLBACK xml_reader_get_depth(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return -1;

  return CefXmlReaderCppToC::Get(self)->GetDepth();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_local_name(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetLocalName();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_prefix(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetPrefix();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_qualified_name(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetQualifiedName();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_namespace_uri(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetNamespaceURI();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_base_uri(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetBaseURI();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_xml_lang(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetXmlLang();
  return retStr.DetachToUserFree();
}

int CEF_CALLBACK xml_reader_is_empty_element(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->IsEmptyElement();
}

int CEF_CALLBACK xml_reader_has_value(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->HasValue();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_value(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetValue();
  return retStr.DetachToUserFree();
}

int CEF_CALLBACK xml_reader_has_attributes(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->HasAttributes();
}

size_t CEF_CALLBACK xml_reader_get_attribute_count(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->GetAttributeCount();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_attribute_byindex(
    struct _cef_xml_reader_t* self, int index)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetAttribute(index);
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_attribute_byqname(
    struct _cef_xml_reader_t* self, const cef_string_t* qualifiedName)
{
  DCHECK(self);
  DCHECK(qualifiedName);
  if(!self || !qualifiedName)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetAttribute(
      CefString(qualifiedName));
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_attribute_bylname(
    struct _cef_xml_reader_t* self, const cef_string_t* localName,
    const cef_string_t* namespaceURI)
{
  DCHECK(self);
  DCHECK(localName);
  DCHECK(namespaceURI);
  if(!self || !localName || !namespaceURI)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetAttribute(
      CefString(localName), CefString(namespaceURI));
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_inner_xml(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetInnerXml();
  return retStr.DetachToUserFree();
}

cef_string_userfree_t CEF_CALLBACK xml_reader_get_outer_xml(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return NULL;

  CefString retStr = CefXmlReaderCppToC::Get(self)->GetOuterXml();
  return retStr.DetachToUserFree();
}

int CEF_CALLBACK xml_reader_get_line_number(struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->GetLineNumber();
}

int CEF_CALLBACK xml_reader_move_to_attribute_byindex(
    struct _cef_xml_reader_t* self, int index)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToAttribute(index);
}

int CEF_CALLBACK xml_reader_move_to_attribute_byqname(
    struct _cef_xml_reader_t* self, const cef_string_t* qualifiedName)
{
  DCHECK(self);
  DCHECK(qualifiedName);
  if(!self || !qualifiedName)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToAttribute(
      CefString(qualifiedName));
}

int CEF_CALLBACK xml_reader_move_to_attribute_bylname(
    struct _cef_xml_reader_t* self, const cef_string_t* localName,
    const cef_string_t* namespaceURI)
{
  DCHECK(self);
  DCHECK(localName);
  DCHECK(namespaceURI);
  if(!self || !localName || !namespaceURI)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToAttribute(CefString(localName),
      CefString(namespaceURI));
}

int CEF_CALLBACK xml_reader_move_to_first_attribute(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToFirstAttribute();
}

int CEF_CALLBACK xml_reader_move_to_next_attribute(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToNextAttribute();
}

int CEF_CALLBACK xml_reader_move_to_carrying_element(
    struct _cef_xml_reader_t* self)
{
  DCHECK(self);
  if(!self)
    return 0;

  return CefXmlReaderCppToC::Get(self)->MoveToCarryingElement();
}


// CONSTRUCTOR - Do not edit by hand.

CefXmlReaderCppToC::CefXmlReaderCppToC(CefXmlReader* cls)
    : CefCppToC<CefXmlReaderCppToC, CefXmlReader, cef_xml_reader_t>(cls)
{
  struct_.struct_.move_to_next_node = xml_reader_move_to_next_node;
  struct_.struct_.close = xml_reader_close;
  struct_.struct_.has_error = xml_reader_has_error;
  struct_.struct_.get_error = xml_reader_get_error;
  struct_.struct_.get_type = xml_reader_get_type;
  struct_.struct_.get_depth = xml_reader_get_depth;
  struct_.struct_.get_local_name = xml_reader_get_local_name;
  struct_.struct_.get_prefix = xml_reader_get_prefix;
  struct_.struct_.get_qualified_name = xml_reader_get_qualified_name;
  struct_.struct_.get_namespace_uri = xml_reader_get_namespace_uri;
  struct_.struct_.get_base_uri = xml_reader_get_base_uri;
  struct_.struct_.get_xml_lang = xml_reader_get_xml_lang;
  struct_.struct_.is_empty_element = xml_reader_is_empty_element;
  struct_.struct_.has_value = xml_reader_has_value;
  struct_.struct_.get_value = xml_reader_get_value;
  struct_.struct_.has_attributes = xml_reader_has_attributes;
  struct_.struct_.get_attribute_count = xml_reader_get_attribute_count;
  struct_.struct_.get_attribute_byindex = xml_reader_get_attribute_byindex;
  struct_.struct_.get_attribute_byqname = xml_reader_get_attribute_byqname;
  struct_.struct_.get_attribute_bylname = xml_reader_get_attribute_bylname;
  struct_.struct_.get_inner_xml = xml_reader_get_inner_xml;
  struct_.struct_.get_outer_xml = xml_reader_get_outer_xml;
  struct_.struct_.get_line_number = xml_reader_get_line_number;
  struct_.struct_.move_to_attribute_byindex =
      xml_reader_move_to_attribute_byindex;
  struct_.struct_.move_to_attribute_byqname =
      xml_reader_move_to_attribute_byqname;
  struct_.struct_.move_to_attribute_bylname =
      xml_reader_move_to_attribute_bylname;
  struct_.struct_.move_to_first_attribute = xml_reader_move_to_first_attribute;
  struct_.struct_.move_to_next_attribute = xml_reader_move_to_next_attribute;
  struct_.struct_.move_to_carrying_element =
      xml_reader_move_to_carrying_element;
}

#ifndef NDEBUG
template<> long CefCppToC<CefXmlReaderCppToC, CefXmlReader,
    cef_xml_reader_t>::DebugObjCt = 0;
#endif

