// Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// A portion of this file was generated by the CEF translator tool.  When
// making changes by hand only do so within the body of existing static and
// virtual method implementations. See the translator.README.txt file in the
// tools directory for more information.
//

#include "libcef_dll/ctocpp/stream_reader_ctocpp.h"
#include "libcef_dll/ctocpp/xml_reader_ctocpp.h"


// STATIC METHODS - Body may be edited by hand.

CefRefPtr<CefXmlReader> CefXmlReader::Create(CefRefPtr<CefStreamReader> stream,
    EncodingType encodingType, const CefString& URI)
{
  cef_xml_reader_t* impl = cef_xml_reader_create(
      CefStreamReaderCToCpp::Unwrap(stream), encodingType, URI.GetStruct());
  if(impl)
    return CefXmlReaderCToCpp::Wrap(impl);
  return NULL;
}


// VIRTUAL METHODS - Body may be edited by hand.

bool CefXmlReaderCToCpp::MoveToNextNode()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_next_node))
    return false;

  return struct_->move_to_next_node(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::Close()
{
  if(CEF_MEMBER_MISSING(struct_, close))
    return false;

  return struct_->close(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::HasError()
{
  if(CEF_MEMBER_MISSING(struct_, has_error))
    return false;

  return struct_->has_error(struct_) ? true : false;
}

CefString CefXmlReaderCToCpp::GetError()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_error))
    return str;

  cef_string_userfree_t strPtr = struct_->get_error(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefXmlReader::NodeType CefXmlReaderCToCpp::GetType()
{
  if(CEF_MEMBER_MISSING(struct_, get_type))
    return XML_NODE_UNSUPPORTED;

  return struct_->get_type(struct_);
}

int CefXmlReaderCToCpp::GetDepth()
{
  if(CEF_MEMBER_MISSING(struct_, get_depth))
    return -1;

  return struct_->get_depth(struct_);
}

CefString CefXmlReaderCToCpp::GetLocalName()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_local_name))
    return str;

  cef_string_userfree_t strPtr = struct_->get_local_name(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetPrefix()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_prefix))
    return str;

  cef_string_userfree_t strPtr = struct_->get_prefix(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetQualifiedName()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_qualified_name))
    return str;

  cef_string_userfree_t strPtr = struct_->get_qualified_name(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetNamespaceURI()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_namespace_uri))
    return str;

  cef_string_userfree_t strPtr = struct_->get_namespace_uri(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetBaseURI()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_base_uri))
    return str;

  cef_string_userfree_t strPtr = struct_->get_base_uri(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetXmlLang()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_xml_lang))
    return str;

  cef_string_userfree_t strPtr = struct_->get_xml_lang(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

bool CefXmlReaderCToCpp::IsEmptyElement()
{
  if(CEF_MEMBER_MISSING(struct_, is_empty_element))
    return false;

  return struct_->is_empty_element(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::HasValue()
{
  if(CEF_MEMBER_MISSING(struct_, has_value))
    return false;

  return struct_->has_value(struct_) ? true : false;
}

CefString CefXmlReaderCToCpp::GetValue()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_value))
    return str;

  cef_string_userfree_t strPtr = struct_->get_value(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

bool CefXmlReaderCToCpp::HasAttributes()
{
  if(CEF_MEMBER_MISSING(struct_, has_attributes))
    return false;

  return struct_->has_attributes(struct_) ? true : false;
}

size_t CefXmlReaderCToCpp::GetAttributeCount()
{
  if(CEF_MEMBER_MISSING(struct_, get_attribute_count))
    return 0;

  return struct_->get_attribute_count(struct_);
}

CefString CefXmlReaderCToCpp::GetAttribute(int index)
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_byindex))
    return str;

  cef_string_userfree_t strPtr = struct_->get_attribute_byindex(struct_, index);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetAttribute(const CefString& qualifiedName)
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_byqname))
    return str;

  cef_string_userfree_t strPtr = struct_->get_attribute_byqname(struct_,
      qualifiedName.GetStruct());
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetAttribute(const CefString& localName,
    const CefString& namespaceURI)
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_attribute_bylname))
    return str;

  cef_string_userfree_t strPtr = struct_->get_attribute_bylname(struct_,
      localName.GetStruct(), namespaceURI.GetStruct());
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetInnerXml()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_inner_xml))
    return str;

  cef_string_userfree_t strPtr = struct_->get_inner_xml(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

CefString CefXmlReaderCToCpp::GetOuterXml()
{
  CefString str;
  if(CEF_MEMBER_MISSING(struct_, get_outer_xml))
    return str;

  cef_string_userfree_t strPtr = struct_->get_outer_xml(struct_);
  str.AttachToUserFree(strPtr);
  return str;
}

int CefXmlReaderCToCpp::GetLineNumber()
{
  if(CEF_MEMBER_MISSING(struct_, get_line_number))
    return false;

  return struct_->get_line_number(struct_);
}

bool CefXmlReaderCToCpp::MoveToAttribute(int index)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_byindex))
    return false;

  return struct_->move_to_attribute_byindex(struct_, index) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToAttribute(const CefString& qualifiedName)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_byqname))
    return false;

  return struct_->move_to_attribute_byqname(struct_, qualifiedName.GetStruct())?
      true : false;
}

bool CefXmlReaderCToCpp::MoveToAttribute(const CefString& localName,
    const CefString& namespaceURI)
{
  if(CEF_MEMBER_MISSING(struct_, move_to_attribute_bylname))
    return false;

  return struct_->move_to_attribute_bylname(struct_, localName.GetStruct(),
      namespaceURI.GetStruct()) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToFirstAttribute()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_first_attribute))
    return false;

  return struct_->move_to_first_attribute(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToNextAttribute()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_next_attribute))
    return false;

  return struct_->move_to_next_attribute(struct_) ? true : false;
}

bool CefXmlReaderCToCpp::MoveToCarryingElement()
{
  if(CEF_MEMBER_MISSING(struct_, move_to_carrying_element))
    return false;

  return struct_->move_to_carrying_element(struct_) ? true : false;
}


#ifndef NDEBUG
template<> long CefCToCpp<CefXmlReaderCToCpp, CefXmlReader,
    cef_xml_reader_t>::DebugObjCt = 0;
#endif

