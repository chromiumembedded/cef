diff --git chrome/browser/extensions/api/chrome_extensions_api_client.cc chrome/browser/extensions/api/chrome_extensions_api_client.cc
index ca334639932840c3e0164e82247319649e5ec24c..4eaa739f00442e98716ebcc0ecb053b4e61179da 100644
--- chrome/browser/extensions/api/chrome_extensions_api_client.cc
+++ chrome/browser/extensions/api/chrome_extensions_api_client.cc
@@ -16,6 +16,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
+#include "cef/libcef/features/features.h"
 #include "chrome/browser/extensions/api/automation_internal/chrome_automation_internal_api_delegate.h"
 #include "chrome/browser/extensions/api/declarative_content/chrome_content_rules_registry.h"
 #include "chrome/browser/extensions/api/declarative_content/default_content_predicate_evaluators.h"
@@ -90,6 +91,10 @@
 #include "chromeos/ash/components/settings/cros_settings.h"
 #endif
 
+#if BUILDFLAG(ENABLE_CEF)
+#include "cef/libcef/browser/chrome/extensions/chrome_mime_handler_view_guest_delegate_cef.h"
+#endif
+
 #if BUILDFLAG(ENABLE_PRINTING)
 #include "chrome/browser/printing/printing_init.h"
 #endif
@@ -339,7 +344,11 @@ ChromeExtensionsAPIClient::CreateGuestViewManagerDelegate() const {
 std::unique_ptr<MimeHandlerViewGuestDelegate>
 ChromeExtensionsAPIClient::CreateMimeHandlerViewGuestDelegate(
     MimeHandlerViewGuest* guest) const {
+#if BUILDFLAG(ENABLE_CEF)
+  return std::make_unique<ChromeMimeHandlerViewGuestDelegateCef>(guest);
+#else
   return std::make_unique<ChromeMimeHandlerViewGuestDelegate>();
+#endif
 }
 
 std::unique_ptr<WebViewGuestDelegate>
diff --git chrome/browser/extensions/api/tabs/tabs_api_non_android.cc chrome/browser/extensions/api/tabs/tabs_api_non_android.cc
index 52d32453933018880b8c7bf2253d7f28997bcceb..43113863ce4eb414e49082afc67e4ea10f4eb183 100644
--- chrome/browser/extensions/api/tabs/tabs_api_non_android.cc
+++ chrome/browser/extensions/api/tabs/tabs_api_non_android.cc
@@ -877,11 +877,10 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   }
 
   // tabs_internal::GetTabById may return a null window for prerender tabs.
-  if (!window || !window->SupportsTabs()) {
-    return RespondNow(Error(ExtensionTabUtil::kNoCurrentWindowError));
+  TabStripModel* tab_strip = nullptr;
+  if (window && window->SupportsTabs()) {
+    tab_strip = window->GetBrowser()->tab_strip_model();
   }
-  Browser* browser = window->GetBrowser();
-  TabStripModel* tab_strip = browser->tab_strip_model();
 
   // Cache the original web contents.
   content::WebContents* original_contents = contents;
@@ -903,7 +902,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
         kCannotUpdateMuteCaptured, base::NumberToString(tab_id))));
   }
 
-  if (params->update_properties.opener_tab_id) {
+  if (tab_strip && params->update_properties.opener_tab_id) {
     int opener_id = *params->update_properties.opener_tab_id;
     WebContents* opener_contents = nullptr;
     if (opener_id == tab_id) {
@@ -938,7 +937,7 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
         ->SetAutoDiscardable(state);
   }
 
-  if (params->update_properties.pinned) {
+  if (tab_strip && params->update_properties.pinned) {
     // Bug fix for crbug.com/1197888. Don't let the extension update the tab if
     // the user is dragging tabs.
     if (!ExtensionTabUtil::IsTabStripEditable()) {
@@ -959,7 +958,8 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
   // Navigate the tab to a new location if the url is different.
   if (params->update_properties.url) {
     std::string updated_url = *params->update_properties.url;
-    if (browser->profile()->IsIncognitoProfile() &&
+    auto* profile = Profile::FromBrowserContext(browser_context());
+    if (profile->IsIncognitoProfile() &&
         !IsURLAllowedInIncognito(GURL(updated_url))) {
       return RespondNow(Error(ErrorUtils::FormatErrorMessage(
           tabs_constants::kURLsNotAllowedInIncognitoError, updated_url)));
@@ -977,9 +977,8 @@ ExtensionFunction::ResponseAction TabsUpdateFunction::Run() {
 
 #if BUILDFLAG(FULL_SAFE_BROWSING)
     tabs_internal::NotifyExtensionTelemetry(
-        Profile::FromBrowserContext(browser_context()), extension(),
-        safe_browsing::TabsApiInfo::UPDATE, current_url, updated_url,
-        js_callstack());
+        profile, extension(), safe_browsing::TabsApiInfo::UPDATE, current_url,
+        updated_url, js_callstack());
 #endif
   }
 
@@ -1039,7 +1038,7 @@ bool TabsUpdateFunction::UpdateActiveTab(
     return false;
   }
 
-  if (tab_strip->active_index() != tab_index) {
+  if (tab_strip && tab_strip->active_index() != tab_index) {
     tab_strip->ActivateTabAt(tab_index);
     DCHECK_EQ(contents, tab_strip->GetActiveWebContents());
   }
@@ -1063,9 +1062,9 @@ bool TabsUpdateFunction::UpdateHighlightedTab(
     return false;
   }
 
-  if (params.update_properties.highlighted.value()) {
+  if (tab_strip && params.update_properties.highlighted.value()) {
     tab_strip->SelectTabAt(tab_index);
-  } else {
+  } else if (tab_strip) {
     tab_strip->DeselectTabAt(tab_index);
   }
   return true;
diff --git chrome/browser/extensions/extension_tab_util.cc chrome/browser/extensions/extension_tab_util.cc
index 490b333d9fea964bc0bcf4ac64a32e6e410b186b..7983d0b1fca7a47b7163cffd6ac0ceb3715f97a0 100644
--- chrome/browser/extensions/extension_tab_util.cc
+++ chrome/browser/extensions/extension_tab_util.cc
@@ -64,6 +64,7 @@
 #include "chrome/browser/ui/android/tab_model/tab_model_list.h"
 #else
 #include "base/types/expected_macros.h"
+#include "cef/libcef/features/features.h"
 #include "chrome/browser/renderer_host/chrome_navigation_ui_data.h"
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_external.h"
 #include "chrome/browser/tab_group_sync/tab_group_sync_service_factory.h"
@@ -89,6 +90,10 @@
 
 static_assert(BUILDFLAG(ENABLE_EXTENSIONS_CORE));
 
+#if BUILDFLAG(ENABLE_CEF)
+#include "cef/libcef/browser/chrome/extensions/chrome_extension_util.h"
+#endif
+
 using content::NavigationEntry;
 using content::WebContents;
 using extensions::mojom::APIPermissionID;
@@ -903,6 +908,15 @@ bool ExtensionTabUtil::GetTabById(int tab_id,
     }
   }
 #endif  // BUILDFLAG(IS_ANDROID)
+
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef::GetAlloyTabById(tab_id, profile, include_incognito, out_contents)) {
+    // |out_window| and |out_tab_index| are tied to a specific Browser window,
+    // which doesn't exist for an Alloy style browser.
+    return true;
+  }
+#endif
+
   // Prerendering tab is not visible and it cannot be in `TabStripModel`, if the
   // tab id exists as a prerendering tab, and the API will returns
   // `api::tabs::TAB_INDEX_NONE` for `out_tab_index` and a valid `WebContents`.
diff --git chrome/browser/ui/tab_helpers.h chrome/browser/ui/tab_helpers.h
index ec26ac19c07801af29e8f755fcbc9f71be17dee1..928536d17dbb15cee42aacc2bac5a57576514109 100644
--- chrome/browser/ui/tab_helpers.h
+++ chrome/browser/ui/tab_helpers.h
@@ -6,6 +6,7 @@
 #define CHROME_BROWSER_UI_TAB_HELPERS_H_
 
 #include "build/build_config.h"
+#include "cef/libcef/features/features.h"
 
 #if BUILDFLAG(IS_ANDROID)
 
@@ -41,6 +42,10 @@ namespace tabs {
 class TabModel;
 }  // namespace tabs
 
+#if BUILDFLAG(ENABLE_CEF)
+class CefBrowserPlatformDelegateAlloy;
+#endif
+
 // A "tab contents" is a WebContents that is used as a tab in a browser window
 // (or the equivalent on Android). The TabHelpers class allows specific classes
 // to attach the set of tab helpers that is used for tab contents.
@@ -80,6 +85,10 @@ class TabHelpers {
   // Link Preview shows a preview of a page, then promote it as a new tab.
   friend class PreviewTab;
 
+#if BUILDFLAG(ENABLE_CEF)
+  friend class CefBrowserPlatformDelegateAlloy;
+#endif
+
   // FYI: Do NOT add any more friends here. The functions above are the ONLY
   // ones that need to call AttachTabHelpers; if you think you do, re-read the
   // design document linked above, especially the section "Reusing tab helpers".
