diff --git chrome/browser/browser_about_handler.cc chrome/browser/browser_about_handler.cc
index 08949a69415dfa9f836e00929a34330a34546ce2..e417f50fa68e274b80c0d45bdaa45c7b22fd6dcd 100644
--- chrome/browser/browser_about_handler.cc
+++ chrome/browser/browser_about_handler.cc
@@ -25,6 +25,10 @@
 
 namespace {
 
+bool IsChromeIgnoreUrl(const std::string& spec) {
+  return base::EqualsCaseInsensitiveASCII(spec, "chrome://ignore/");
+}
+
 bool IsNonNavigationAboutUrl(const GURL& url) {
   if (!url.is_valid()) {
     return false;
@@ -32,8 +36,8 @@ bool IsNonNavigationAboutUrl(const GURL& url) {
 
   const std::string spec(url.spec());
   return base::EqualsCaseInsensitiveASCII(spec, chrome::kChromeUIRestartURL) ||
-         base::EqualsCaseInsensitiveASCII(spec, chrome::kChromeUIQuitURL);
-  ;
+         base::EqualsCaseInsensitiveASCII(spec, chrome::kChromeUIQuitURL) ||
+         IsChromeIgnoreUrl(spec);
 }
 
 }  // namespace
@@ -102,5 +106,8 @@ bool HandleNonNavigationAboutURL(const GURL& url,
         FROM_HERE, base::BindOnce(&chrome::AttemptExit));
     return true;
   }
+  if (IsChromeIgnoreUrl(spec)) {
+    return true;
+  }
   NOTREACHED();
 }
diff --git chrome/browser/devtools/devtools_window.cc chrome/browser/devtools/devtools_window.cc
index 65c1e34883e441121f6c3085b2f3b9d33cacc377..a830f72075de4e572bfe63a992ddd6e2f3ce740e 100644
--- chrome/browser/devtools/devtools_window.cc
+++ chrome/browser/devtools/devtools_window.cc
@@ -44,6 +44,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/search_engines/template_url_service_factory.h"
 #include "chrome/browser/task_manager/web_contents_tags.h"
+#include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/dialogs/browser_dialogs.h"
 #include "chrome/browser/ui/prefs/prefs_tab_helper.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -1366,6 +1367,13 @@ DevToolsWindow* DevToolsWindow::Create(
     if (!browser || !browser->window()->CanDockDevTools()) {
       can_dock = false;
     }
+
+#if BUILDFLAG(ENABLE_CEF)
+    if (can_dock && browser && browser->cef_delegate()) {
+      // Don't dock DevTools for CEF-managed browsers.
+      can_dock = false;
+    }
+#endif
   }
 #endif  // !BUILDFLAG(IS_ANDROID)
 
@@ -1823,7 +1831,9 @@ void DevToolsWindow::OpenInNewTab(const GURL& url) {
                                        /*navigation_handle_callback=*/{})) {
 #if BUILDFLAG(IS_ANDROID)
     NOTIMPLEMENTED();
-#else
+#elif !BUILDFLAG(ENABLE_CEF)
+    // Remove default behavior when CEF handles the open via OnOpenURLFromTab.
+    // See CEF issue #3735.
     chrome::ScopedTabbedBrowserDisplayer displayer(profile_);
     chrome::AddSelectedTabWithURL(displayer.browser(), fixed_url,
                                   ui::PAGE_TRANSITION_LINK);
@@ -2027,12 +2037,30 @@ void DevToolsWindow::CreateDevToolsBrowser() {
       Browser::CreationStatus::kOk) {
     return;
   }
-  browser_ =
-      Browser::Create(Browser::CreateParams::CreateForDevTools(profile_));
-  browser_->GetTabStripModel()->AddWebContents(
-      OwnedMainWebContents::TakeWebContents(
-          std::move(owned_main_web_contents_)),
-      -1, ui::PAGE_TRANSITION_AUTO_TOPLEVEL, AddTabTypes::ADD_ACTIVE);
+
+  auto* inspected_web_contents = GetInspectedWebContents();
+  Browser* opener = nullptr;
+  if (inspected_web_contents) {
+    opener = chrome::FindBrowserWithTab(inspected_web_contents);
+  }
+  auto devtools_contents = OwnedMainWebContents::TakeWebContents(
+      std::move(owned_main_web_contents_));
+
+#if BUILDFLAG(ENABLE_CEF)
+  // If a Browser is created, it will take ownership of |devtools_contents|.
+  browser_ = cef::BrowserDelegate::CreateDevToolsBrowser(
+      profile_, opener, inspected_web_contents, devtools_contents);
+#endif
+
+  if (!browser_) {
+    auto create_params = Browser::CreateParams::CreateForDevTools(profile_);
+    create_params.opener = opener;
+
+    browser_ = Browser::Create(std::move(create_params));
+    browser_->GetTabStripModel()->AddWebContents(
+        std::move(devtools_contents),
+        -1, ui::PAGE_TRANSITION_AUTO_TOPLEVEL, AddTabTypes::ADD_ACTIVE);
+  }
 #endif
   OverrideAndSyncDevToolsRendererPrefs();
 }
diff --git chrome/browser/ui/BUILD.gn chrome/browser/ui/BUILD.gn
index dcdfb2edc4a03ee48fe4473f291b6686448c4710..4c81fd5697ba86a5521753675c2c01e0a57a4647 100644
--- chrome/browser/ui/BUILD.gn
+++ chrome/browser/ui/BUILD.gn
@@ -7,6 +7,7 @@ import("//build/config/compiler/compiler.gni")
 import("//build/config/features.gni")
 import("//build/config/ozone.gni")
 import("//build/config/ui.gni")
+import("//cef/libcef/features/features.gni")
 import("//chrome/browser/buildflags.gni")
 import("//chrome/common/features.gni")
 import("//components/captive_portal/core/features.gni")
@@ -228,6 +229,10 @@ static_library("ui") {
     "//build/config/compiler:wexit_time_destructors",
   ]
 
+  if (enable_cef) {
+    configs += [ "//cef/libcef/features:config" ]
+  }
+
   public_deps = [
     # WARNING WARNING WARNING
     # New dependencies outside of //chrome/browser should be added to
@@ -261,6 +266,7 @@ static_library("ui") {
     "//build/config/linux/dbus:buildflags",
     "//build/util:chromium_git_revision",
     "//cc/paint",
+    "//cef/libcef/features:buildflags",
     "//chrome:resources",
     "//chrome:strings",
     "//chrome/app:chrome_dll_resources",
@@ -696,6 +702,13 @@ static_library("ui") {
     deps += [ "//chrome/browser/compose" ]
   }
 
+  if (enable_cef) {
+    deps += [
+      "//cef:cef_resources",
+      "//cef/libcef/features:deps",
+    ]
+  }
+
   # TODO(crbug.com/41437292): Remove this circular dependency.
   # Any circular includes must depend on the target "//chrome/browser:browser_public_dependencies".
   # These are all-platform circular includes.
@@ -4482,8 +4495,6 @@ static_library("ui") {
       "views/tabs/tab_slot_view.h",
       "views/tabs/tab_strip.cc",
       "views/tabs/tab_strip.h",
-      "views/tabs/tab_strip_action_container.cc",
-      "views/tabs/tab_strip_action_container.h",
       "views/tabs/tab_strip_control_button.cc",
       "views/tabs/tab_strip_control_button.h",
       "views/tabs/tab_strip_controller.h",
@@ -4786,7 +4797,6 @@ static_library("ui") {
       # componentized:
       # c/b/ui/browser.h, browser_finder.h, browser_window.h.
       # c/b/ui/passwords/passwords_model_delegate.h, passwords_client_ui_delegate.h.
-      "//chrome/browser/actor/ui",
       "//chrome/browser/ui:tab_search_feature",
       "//chrome/browser/ui/views/zoom",
       "//chrome/browser/ui/waap:waap_utils",
@@ -5270,6 +5280,7 @@ static_library("ui") {
   if (enable_printing) {
     deps += [
       "//components/printing/browser",
+      "//components/printing/common:mojo_interfaces",
       "//printing",
     ]
   }
@@ -5462,6 +5473,8 @@ static_library("ui") {
     allow_circular_includes_from += [ "//chrome/browser/glic/fre" ]
     if (!is_android) {
       sources += [
+        "views/tabs/tab_strip_action_container.cc",
+        "views/tabs/tab_strip_action_container.h",
         "webui/settings/glic_handler.cc",
         "webui/settings/glic_handler.h",
       ]
diff --git chrome/browser/ui/browser.cc chrome/browser/ui/browser.cc
index cb1c559fa9cb0a05004197765e19a4195952cd91..309c446ee765d4952b07c22017a4d13a598c848a 100644
--- chrome/browser/ui/browser.cc
+++ chrome/browser/ui/browser.cc
@@ -303,6 +303,25 @@
 #include "chrome/browser/ui/overscroll_pref_manager.h"
 #endif  // defined(USE_AURA)
 
+#if BUILDFLAG(ENABLE_CEF)
+#define CALL_CEF_DELEGATE(name, ...)          \
+  if (cef_browser_delegate_) {                \
+    cef_browser_delegate_->name(__VA_ARGS__); \
+  }
+#define CALL_CEF_DELEGATE_RETURN(name, ...)          \
+  if (cef_browser_delegate_) {                       \
+    return cef_browser_delegate_->name(__VA_ARGS__); \
+  }
+#define CALL_CEF_DELEGATE_RESULT(name, result, ...)    \
+  if (cef_browser_delegate_) {                         \
+    result = cef_browser_delegate_->name(__VA_ARGS__); \
+  }
+#else  // !BUILDFLAG(ENABLE_CEF)
+#define CALL_CEF_DELEGATE(name, ...)
+#define CALL_CEF_DELEGATE_RETURN(name, ...)
+#define CALL_CEF_DELEGATE_RESULT(name, result, ...)
+#endif
+
 using base::UserMetricsAction;
 using content::NavigationController;
 using content::NavigationEntry;
@@ -571,6 +590,10 @@ Browser::Browser(const CreateParams& params)
       type_(params.type),
       profile_(params.profile),
       window_(nullptr),
+#if BUILDFLAG(ENABLE_CEF)
+      cef_browser_delegate_(
+          cef::BrowserDelegate::Create(this, params.cef_params, params.opener)),
+#endif
       tab_strip_model_delegate_(
           std::make_unique<chrome::BrowserTabStripModelDelegate>(this)),
       tab_strip_model_(std::make_unique<TabStripModel>(
@@ -643,9 +666,6 @@ Browser::Browser(const CreateParams& params)
   }
 #endif  // BUILDFLAG(IS_OZONE)
 
-  if (params.window) {
-    CHECK_IS_TEST() << "Browser::CreateParams::window is a test-only param";
-  }
   window_ =
       params.window
           ? std::unique_ptr<BrowserWindow, BrowserWindowDeleter>(params.window)
@@ -660,9 +680,19 @@ Browser::Browser(const CreateParams& params)
     session_service->WindowOpened(this);
   }
 
-  // Initialize the browser features that rely on the browser window now that it
-  // is initialized.
-  features_->InitPostWindowConstruction(this);
+  const bool views_hosted =
+#if BUILDFLAG(ENABLE_CEF)
+      cef_delegate() && cef_delegate()->IsViewsHosted();
+#else
+      false;
+#endif
+
+  if (!views_hosted) {
+    // Initialize the browser features that rely on the browser window now that
+    // it is initialized. This will instead be called from
+    // BrowserView::AddedToWidget() for CEF Views-hosted windows.
+    features_->InitPostWindowConstruction(this);
+  }
 
   // All initialization is complete; after this point, the browser should be on
   // the browser list until it is marked for destruction.
@@ -776,7 +806,12 @@ GURL Browser::GetNewTabURL() const {
 }
 
 gfx::Image Browser::GetCurrentPageIcon() const {
-  WebContents* web_contents = tab_strip_model_->GetActiveWebContents();
+  // For document picture-in-picture windows, we use the favicon from the opener
+  // WebContents instead of the picture-in-picture WebContents itself.
+  content::WebContents* web_contents =
+      is_type_picture_in_picture()
+          ? PictureInPictureWindowManager::GetInstance()->GetWebContents()
+          : tab_strip_model_->GetActiveWebContents();
   // |web_contents| can be NULL since GetCurrentPageIcon() is called by the
   // window during the window's creation (before tabs have been added).
   favicon::FaviconDriver* favicon_driver =
@@ -1219,6 +1254,10 @@ BrowserWindowInterface::Type Browser::GetType() const {
   return type_;
 }
 
+bool Browser::IsNormalBrowser() const {
+  return BrowserWindowFeatures::IsNormalBrowser(this);
+}
+
 web_app::AppBrowserController* Browser::app_controller() {
   return web_app::AppBrowserController::From(this);
 }
@@ -1424,6 +1463,8 @@ void Browser::WindowFullscreenStateChanged() {
   GetCommandController()->FullscreenStateChanged();
   BookmarkBarController::From(this)->UpdateBookmarkBarState(
       BookmarkBarController::StateChangeReason::kToggleFullscreen);
+
+  CALL_CEF_DELEGATE(WindowFullscreenStateChanged);
 }
 
 void Browser::FullscreenTopUIStateChanged() {
@@ -1852,6 +1893,15 @@ content::KeyboardEventProcessingResult Browser::PreHandleKeyboardEvent(
     return content::KeyboardEventProcessingResult::HANDLED;
   }
 
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_) {
+    auto result = cef_browser_delegate_->PreHandleKeyboardEvent(source, event);
+    if (result != content::KeyboardEventProcessingResult::NOT_HANDLED) {
+      return result;
+    }
+  }
+#endif
+
   return window()->PreHandleKeyboardEvent(event);
 }
 
@@ -1859,8 +1909,18 @@ bool Browser::HandleKeyboardEvent(content::WebContents* source,
                                   const NativeWebKeyboardEvent& event) {
   DevToolsWindow* devtools_window =
       DevToolsWindow::GetInstanceForInspectedWebContents(source);
-  return (devtools_window && devtools_window->ForwardKeyboardEvent(event)) ||
-         window()->HandleKeyboardEvent(event);
+  if (devtools_window && devtools_window->ForwardKeyboardEvent(event)) {
+    return true;
+  }
+
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_ &&
+      cef_browser_delegate_->HandleKeyboardEvent(source, event)) {
+    return true;
+  }
+#endif
+
+  return window()->HandleKeyboardEvent(event);
 }
 
 bool Browser::TabsNeedBeforeUnloadFired() const {
@@ -1946,9 +2006,14 @@ bool Browser::IsBackForwardCacheSupported(content::WebContents& web_contents) {
 content::PreloadingEligibility Browser::IsPrerender2Supported(
     content::WebContents& web_contents,
     content::PreloadingTriggerType trigger_type) {
+#if BUILDFLAG(ENABLE_CEF)
+  // Prerender is not supported in CEF. See issue #3664.
+  return content::PreloadingEligibility::kPreloadingDisabled;
+#else
   Profile* profile =
       Profile::FromBrowserContext(web_contents.GetBrowserContext());
   return prefetch::IsSomePreloadingEnabled(*profile->GetPrefs());
+#endif
 }
 
 bool Browser::ShouldShowStaleContentOnEviction(content::WebContents* source) {
@@ -2009,6 +2074,14 @@ WebContents* Browser::OpenURLFromTab(
                                   std::move(navigation_handle_callback));
   }
 
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_ &&
+      !cef_browser_delegate_->OpenURLFromTabEx(source, params,
+                                               navigation_handle_callback)) {
+    return nullptr;
+  }
+#endif
+
   NavigateParams nav_params(this, params.url, params.transition);
   nav_params.FillNavigateParamsFromOpenURLParams(params);
   nav_params.source_contents = source;
@@ -2188,6 +2261,8 @@ void Browser::LoadingStateChanged(WebContents* source,
                                   bool should_show_loading_ui) {
   ScheduleUIUpdate(source, content::INVALIDATE_TYPE_LOAD);
   UpdateWindowForLoadingStateChanged(source, should_show_loading_ui);
+
+  CALL_CEF_DELEGATE(LoadingStateChanged, source, should_show_loading_ui);
 }
 
 void Browser::CloseContents(WebContents* source) {
@@ -2197,6 +2272,13 @@ void Browser::CloseContents(WebContents* source) {
 }
 
 void Browser::SetContentsBounds(WebContents* source, const gfx::Rect& bounds) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_ &&
+      cef_browser_delegate_->SetContentsBoundsEx(source, bounds)) {
+    return;
+  }
+#endif
+
   if (is_type_normal()) {
     return;
   }
@@ -2217,6 +2299,8 @@ void Browser::SetContentsBounds(WebContents* source, const gfx::Rect& bounds) {
 }
 
 void Browser::UpdateTargetURL(WebContents* source, const GURL& url) {
+  CALL_CEF_DELEGATE(UpdateTargetURL, source, url);
+
   std::vector<StatusBubble*> status_bubbles = GetStatusBubbles();
   for (StatusBubble* status_bubble : status_bubbles) {
     StatusBubbleViews* status_bubble_views =
@@ -2263,15 +2347,31 @@ void Browser::ContentsZoomChange(bool zoom_in) {
 }
 
 bool Browser::TakeFocus(content::WebContents* source, bool reverse) {
+  CALL_CEF_DELEGATE_RETURN(TakeFocus, source, reverse);
   return false;
 }
 
+void Browser::CanDownload(const GURL& url,
+                          const std::string& request_method,
+                          base::OnceCallback<void(bool)> callback) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_) {
+    cef_browser_delegate_->CanDownload(url, request_method,
+                                       std::move(callback));
+    return;
+  }
+#endif
+  std::move(callback).Run(true);
+}
+
 bool Browser::DidAddMessageToConsole(
     content::WebContents* source,
     blink::mojom::ConsoleMessageLevel log_level,
     const std::u16string& message,
     int32_t line_no,
     const std::u16string& source_id) {
+  CALL_CEF_DELEGATE_RETURN(DidAddMessageToConsole, source, log_level, message,
+                           line_no, source_id);
   static bool is_headless_mode = headless::IsHeadlessMode();
   if (is_headless_mode) {
     const bool is_builtin_component = !!source->GetWebUI();
@@ -2425,12 +2525,24 @@ void Browser::WebContentsCreated(WebContents* source_contents,
   // to track `new_contents` after it is added to its TabModel this override can
   // be removed.
   CreateSessionServiceTabHelper(new_contents);
+
+  CALL_CEF_DELEGATE(WebContentsCreated, source_contents,
+                    opener_render_process_id, opener_render_frame_id,
+                    frame_name, target_url, new_contents);
 }
 
 void Browser::RendererUnresponsive(
     WebContents* source,
     content::RenderWidgetHost* render_widget_host,
     base::RepeatingClosure hang_monitor_restarter) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_ &&
+      cef_browser_delegate_->RendererUnresponsiveEx(source, render_widget_host,
+                                                    hang_monitor_restarter)) {
+    return;
+  }
+#endif
+
   // Don't show the page hung dialog when a HTML popup hangs because
   // the dialog will take the focus and immediately close the popup.
   RenderWidgetHostView* view = render_widget_host->GetView();
@@ -2443,6 +2555,13 @@ void Browser::RendererUnresponsive(
 void Browser::RendererResponsive(
     WebContents* source,
     content::RenderWidgetHost* render_widget_host) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_ &&
+      cef_browser_delegate_->RendererResponsiveEx(source, render_widget_host)) {
+    return;
+  }
+#endif
+
   RenderWidgetHostView* view = render_widget_host->GetView();
   if (view && !render_widget_host->GetView()->IsHTMLFormPopup()) {
     TabDialogs::FromWebContents(source)->HideHungRendererDialog(
@@ -2452,6 +2571,15 @@ void Browser::RendererResponsive(
 
 content::JavaScriptDialogManager* Browser::GetJavaScriptDialogManager(
     WebContents* source) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_) {
+    auto* cef_js_dialog_manager =
+        cef_browser_delegate_->GetJavaScriptDialogManager(source);
+    if (cef_js_dialog_manager) {
+      return cef_js_dialog_manager;
+    }
+  }
+#endif
   return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
 }
 
@@ -2487,6 +2615,11 @@ void Browser::DraggableRegionsChanged(
   if (auto* const app_browser_controller = app_controller()) {
     app_browser_controller->DraggableRegionsChanged(regions, contents);
   }
+#if BUILDFLAG(ENABLE_CEF)
+  else if (cef_delegate()) {
+    cef_delegate()->DraggableRegionsChanged(regions, contents);
+  }
+#endif
 }
 
 std::vector<blink::mojom::RelatedApplicationPtr>
@@ -2612,6 +2745,8 @@ void Browser::EnterFullscreenModeForTab(
       ->fullscreen_controller()
       ->EnterFullscreenModeForTab(requesting_frame,
                                   FullscreenTabParams{options.display_id});
+
+  CALL_CEF_DELEGATE(EnterFullscreenModeForTab, requesting_frame, options);
 }
 
 void Browser::ExitFullscreenModeForTab(WebContents* web_contents) {
@@ -2619,6 +2754,8 @@ void Browser::ExitFullscreenModeForTab(WebContents* web_contents) {
       ->exclusive_access_manager()
       ->fullscreen_controller()
       ->ExitFullscreenModeForTab(web_contents);
+
+  CALL_CEF_DELEGATE(ExitFullscreenModeForTab, web_contents);
 }
 
 bool Browser::IsFullscreenForTabOrPending(const WebContents* web_contents) {
@@ -2795,6 +2932,18 @@ void Browser::FindReply(WebContents* web_contents,
   find_tab_helper->HandleFindReply(request_id, number_of_matches,
                                    selection_rect, active_match_ordinal,
                                    final_update);
+  CALL_CEF_DELEGATE(FindReply, web_contents, request_id, number_of_matches,
+                    selection_rect, active_match_ordinal, final_update);
+}
+
+void Browser::UpdatePreferredSize(WebContents* source,
+                                  const gfx::Size& pref_size) {
+  CALL_CEF_DELEGATE(UpdatePreferredSize, source, pref_size);
+}
+
+void Browser::ResizeDueToAutoResize(WebContents* source,
+                                    const gfx::Size& new_size) {
+  CALL_CEF_DELEGATE(ResizeDueToAutoResize, source, new_size);
 }
 
 void Browser::RequestPointerLock(WebContents* web_contents,
@@ -2840,6 +2989,16 @@ void Browser::RequestMediaAccessPermission(
     content::WebContents* web_contents,
     const content::MediaStreamRequest& request,
     content::MediaResponseCallback callback) {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_browser_delegate_) {
+    callback = cef_browser_delegate_->RequestMediaAccessPermissionEx(
+        web_contents, request, std::move(callback));
+    if (callback.is_null()) {
+      return;
+    }
+  }
+#endif
+
   const extensions::Extension* extension =
       GetExtensionForOrigin(profile_, request.security_origin);
   MediaCaptureDevicesDispatcher::GetInstance()->ProcessMediaAccessRequest(
@@ -3428,9 +3587,11 @@ void Browser::OnFileSelectedFromDialog(const GURL& url) {
 // Browser, Getters for UI (private):
 
 std::vector<StatusBubble*> Browser::GetStatusBubbles() {
+  bool show_by_default = true;
+
   // For kiosk and exclusive app mode we want to always hide the status bubble.
   if (IsRunningInAppMode()) {
-    return {};
+    show_by_default = false;
   }
 
   // We hide the status bar for web apps windows as this matches native
@@ -3439,6 +3600,12 @@ std::vector<StatusBubble*> Browser::GetStatusBubbles() {
   auto* const app_browser_controller = app_controller();
   if (app_browser_controller &&
       !app_browser_controller->HasMinimalUiButtons()) {
+    show_by_default = false;
+  }
+
+  bool show = show_by_default;
+  CALL_CEF_DELEGATE_RESULT(ShowStatusBubble, show, show_by_default);
+  if (!show) {
     return {};
   }
 
@@ -3593,6 +3760,8 @@ void Browser::SetAsDelegate(WebContents* web_contents, bool set_delegate) {
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
     web_contents_collection_.StopObserving(web_contents);
   }
+
+  CALL_CEF_DELEGATE(SetAsDelegate, web_contents, set_delegate);
 }
 
 void Browser::TabDetachedAtImpl(content::WebContents* contents,
@@ -3738,6 +3907,15 @@ bool Browser::PictureInPictureBrowserSupportsWindowFeature(
 
 bool Browser::SupportsWindowFeatureImpl(WindowFeature feature,
                                         bool check_can_support) const {
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef_delegate()) {
+    if (auto value = cef_delegate()->SupportsWindowFeature(
+            static_cast<int>(feature))) {
+      return *value;
+    }
+  }
+#endif
+
   switch (type_) {
     case TYPE_NORMAL:
       return NormalBrowserSupportsWindowFeature(feature, check_can_support);
diff --git chrome/browser/ui/browser.h chrome/browser/ui/browser.h
index bc5483d1f30f50927ac8af011edc783767d94896..0b9c747011c9efd400ac9bbfcee329921ebfc9b2 100644
--- chrome/browser/ui/browser.h
+++ chrome/browser/ui/browser.h
@@ -23,6 +23,7 @@
 #include "base/timer/elapsed_timer.h"
 #include "base/types/expected.h"
 #include "build/build_config.h"
+#include "cef/libcef/features/features.h"
 #include "chrome/browser/tab_contents/web_contents_collection.h"
 #include "chrome/browser/themes/theme_service_observer.h"
 #include "chrome/browser/ui/bookmarks/bookmark_bar.h"
@@ -54,6 +55,10 @@
 #include "ui/base/window_open_disposition.h"
 #include "ui/gfx/geometry/rect.h"
 
+#if BUILDFLAG(ENABLE_CEF)
+#include "cef/libcef/browser/chrome/browser_delegate.h"
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 #error This file should only be included on desktop.
 #endif
@@ -318,6 +323,15 @@ class Browser : public TabStripModelObserver,
     // Specifies the width for the uncollapsed Vertical Tab Strip.
     std::optional<int> vertical_tab_strip_uncollapsed_width;
 
+#if BUILDFLAG(ENABLE_CEF)
+    // Opaque CEF-specific configuration. Will be propagated to new Browsers.
+    scoped_refptr<cef::BrowserDelegate::CreateParams> cef_params;
+
+    // Specify the Browser that is opening this popup.
+    // Currently only used with TYPE_PICTURE_IN_PICTURE and TYPE_DEVTOOLS.
+    raw_ptr<BrowserWindowInterface, DanglingUntriaged> opener = nullptr;
+#endif
+
    private:
     friend class Browser;
     friend class WindowSizerChromeOSTest;
@@ -410,6 +424,13 @@ class Browser : public TabStripModelObserver,
     update_ui_immediately_for_testing_ = true;
   }
 
+  // Return true if CEF will expose the toolbar to the client. This value is
+  // used to selectively enable toolbar behaviors such as command processing
+  // and omnibox focus without also including the toolbar in BrowserView layout
+  // calculations.
+  void set_toolbar_overridden(bool val) { toolbar_overridden_ = val; }
+  bool toolbar_overridden() const { return toolbar_overridden_; }
+
   // Accessors ////////////////////////////////////////////////////////////////
 
   const CreateParams& create_params() const { return create_params_; }
@@ -435,6 +456,9 @@ class Browser : public TabStripModelObserver,
   // is done.
   BrowserWindow* window() const { return window_.get(); }
 
+  // Used when the BrowserWindow will outlive this Browser.
+  void ReleaseBrowserWindow() { window_.release(); }
+
   // In production code, each instance of Browser will always instantiate an
   // instance of BrowserView in the constructor. Some tests instantiate a
   // Browser without a BrowserView: this is an anti-pattern and should be
@@ -480,6 +504,12 @@ class Browser : public TabStripModelObserver,
     return features_.get();
   }
 
+#if BUILDFLAG(ENABLE_CEF)
+  cef::BrowserDelegate* cef_delegate() const {
+    return cef_browser_delegate_.get();
+  }
+#endif
+
   base::WeakPtr<Browser> AsWeakPtr();
   base::WeakPtr<const Browser> AsWeakPtr() const;
 
@@ -814,6 +844,7 @@ class Browser : public TabStripModelObserver,
   ExclusiveAccessManager* GetExclusiveAccessManager() override;
   BrowserActions* GetActions() override;
   Type GetType() const override;
+  bool IsNormalBrowser() const override;
   std::vector<tabs::TabInterface*> GetAllTabInterfaces() override;
   Browser* GetBrowserForMigrationOnly() override;
   const Browser* GetBrowserForMigrationOnly() const override;
@@ -916,6 +947,9 @@ class Browser : public TabStripModelObserver,
                           const ui::Event& event) override;
   void ContentsZoomChange(bool zoom_in) override;
   bool TakeFocus(content::WebContents* source, bool reverse) override;
+  void CanDownload(const GURL& url,
+                   const std::string& request_method,
+                   base::OnceCallback<void(bool)> callback) override;
   bool DidAddMessageToConsole(content::WebContents* source,
                               blink::mojom::ConsoleMessageLevel log_level,
                               const std::u16string& message,
@@ -1003,6 +1037,10 @@ class Browser : public TabStripModelObserver,
                  const gfx::Rect& selection_rect,
                  int active_match_ordinal,
                  bool final_update) override;
+  void UpdatePreferredSize(content::WebContents* source,
+                           const gfx::Size& pref_size) override;
+  void ResizeDueToAutoResize(content::WebContents* source,
+                             const gfx::Size& new_size) override;
   void RequestPointerLock(content::WebContents* web_contents,
                           bool user_gesture,
                           bool last_unlocked_by_target) override;
@@ -1263,6 +1301,10 @@ class Browser : public TabStripModelObserver,
   // The active state of this browser.
   bool is_active_ = false;
 
+#if BUILDFLAG(ENABLE_CEF)
+  std::unique_ptr<cef::BrowserDelegate> cef_browser_delegate_;
+#endif
+
   std::unique_ptr<TabStripModelDelegate> const tab_strip_model_delegate_;
   std::unique_ptr<TabStripModel> const tab_strip_model_;
 
@@ -1327,6 +1369,8 @@ class Browser : public TabStripModelObserver,
   const std::string initial_workspace_;
   bool initial_visible_on_all_workspaces_state_;
 
+  bool toolbar_overridden_ = false;
+
   CreationSource creation_source_ = CreationSource::kUnknown;
 
   UnloadController unload_controller_;
diff --git chrome/browser/ui/browser_finder.cc chrome/browser/ui/browser_finder.cc
index a7e0eb934caaa63e4eda432eba2a3e15c7f8bd3d..ba5de50e3d92d05e1848a5f56850007c804a8e4d 100644
--- chrome/browser/ui/browser_finder.cc
+++ chrome/browser/ui/browser_finder.cc
@@ -400,7 +400,14 @@ Browser* FindBrowserWithWindow(gfx::NativeWindow window) {
 Browser* FindBrowserWithActiveWindow() {
   BrowserWindowInterface* browser =
       GetLastActiveBrowserWindowInterfaceWithAnyProfile();
-  return browser && browser->GetWindow()->IsActive()
+  // With CEF, |browser->GetWindow()| may return nullptr during Browser
+  // destruction because the BrowserWindow is destroyed first (in
+  // ChromeBrowserWidget::OnNativeWidgetDestroyed). If multiple BrowserWidgets
+  // are destroyed at the same time then multiple calls to
+  // SynchronouslyDestroyBrowser may be pending execution. In that case, the
+  // first call to this method may find another Browser that is also pending
+  // destruction (has no associated BrowserWindow).
+  return browser && browser->GetWindow() && browser->GetWindow()->IsActive()
              ? browser->GetBrowserForMigrationOnly()
              : nullptr;
 }
diff --git chrome/browser/ui/browser_navigator.cc chrome/browser/ui/browser_navigator.cc
index b5c2da1226eaef4c5aa7a60cd8ba3ff0e3f46a44..5c241fb7305685afd2a28019652ebdd1a3cb5a01 100644
--- chrome/browser/ui/browser_navigator.cc
+++ chrome/browser/ui/browser_navigator.cc
@@ -32,6 +32,7 @@
 #include "chrome/browser/ui/browser_navigator_params.h"
 #include "chrome/browser/ui/browser_navigator_params_utils.h"
 #include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/browser_window/public/browser_window_features.h"
 #include "chrome/browser/ui/browser_window/public/browser_window_interface.h"
 #include "chrome/browser/ui/incognito_allowed_url.h"
 #include "chrome/browser/ui/location_bar/location_bar.h"
@@ -266,6 +267,12 @@ std::tuple<BrowserWindowInterface*, int> GetBrowserAndTabForDisposition(
 
       browser_params.pip_options = pip_options;
 
+      browser_params.can_resize = pip_options->resizable;
+
+#if BUILDFLAG(ENABLE_CEF)
+      browser_params.opener = params.browser;
+#endif
+
       const ui::BaseWindow* const browser_window = params.browser->GetWindow();
       const gfx::NativeWindow native_window =
           browser_window ? browser_window->GetNativeWindow()
@@ -504,7 +511,13 @@ std::unique_ptr<content::WebContents> CreateTargetContents(
   }
 #endif
 
-  return WebContents::Create(create_params);
+  std::unique_ptr<WebContents> target_contents =
+      WebContents::Create(create_params);
+
+  params.browser->GetFeatures().OnWebContentsCreated(params.browser,
+                                                     target_contents.get());
+
+  return target_contents;
 }
 
 }  // namespace
@@ -837,6 +850,11 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
     // navigation happens in a different tab to the link click.
     apps::SetLinkCapturingSourceDisposition(tab_to_insert->GetContents(),
                                             params->disposition);
+
+    // With CEF the BrowserView is created before the TabModel, so we need a
+    // separate initialization of objects that depend on TabModel.
+    params->browser->GetFeatures().InitPostTabModelConstruction(
+        params->browser);
   }
 
   if (params->source_contents == contents_to_navigate_or_insert) {
diff --git chrome/browser/ui/browser_tabstrip.cc chrome/browser/ui/browser_tabstrip.cc
index 8fcba62fa159924eaa33f5c9f1b57dc8ab5db863..25b96e03a9e2598a6c5a6dbf0ad60bf73fb89378 100644
--- chrome/browser/ui/browser_tabstrip.cc
+++ chrome/browser/ui/browser_tabstrip.cc
@@ -34,9 +34,13 @@ content::WebContents* AddAndReturnTabAt(
   // Time new tab page creation time.  We keep track of the timing data in
   // WebContents, but we want to include the time it takes to create the
   // WebContents object too.
+  // For CEF use a PageTransition that matches
+  // CefFrameHostImpl::kPageTransitionExplicit.
   base::TimeTicks new_tab_start_time = base::TimeTicks::Now();
-  NavigateParams params(browser, url.is_empty() ? browser->GetNewTabURL() : url,
-                        ui::PAGE_TRANSITION_TYPED);
+  NavigateParams params(
+      browser, url.is_empty() ? browser->GetNewTabURL() : url,
+      static_cast<ui::PageTransition>(ui::PAGE_TRANSITION_TYPED |
+                                      ui::PAGE_TRANSITION_FROM_ADDRESS_BAR));
   params.disposition = foreground ? WindowOpenDisposition::NEW_FOREGROUND_TAB
                                   : WindowOpenDisposition::NEW_BACKGROUND_TAB;
   params.tabstrip_index = idx;
@@ -92,6 +96,16 @@ content::WebContents* AddWebContents(
   // Can't create a new contents for the current tab - invalid case.
   DCHECK(disposition != WindowOpenDisposition::CURRENT_TAB);
 
+#if BUILDFLAG(ENABLE_CEF)
+  if (browser && browser->cef_delegate() && new_contents) {
+    new_contents =
+        browser->cef_delegate()->AddWebContents(std::move(new_contents));
+    if (!new_contents) {
+      return nullptr;
+    }
+  }
+#endif
+
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source_contents;
   params.url = target_url;
@@ -115,8 +129,6 @@ void CloseWebContents(Browser* browser,
                       bool add_to_history) {
   int index = browser->tab_strip_model()->GetIndexOfWebContents(contents);
   if (index == TabStripModel::kNoTab) {
-    DUMP_WILL_BE_NOTREACHED()
-        << "CloseWebContents called for tab not in our strip";
     return;
   }
 
diff --git chrome/browser/ui/browser_window/internal/browser_window_features.cc chrome/browser/ui/browser_window/internal/browser_window_features.cc
index 545e2827ccee3c7ee8270be81614f166ca460482..5f8c07a2aaa7dc64daa66b0fff1c8caef360b04c 100644
--- chrome/browser/ui/browser_window/internal/browser_window_features.cc
+++ chrome/browser/ui/browser_window/internal/browser_window_features.cc
@@ -113,7 +113,9 @@
 #include "chrome/browser/ui/views/side_panel/side_panel_coordinator.h"
 #include "chrome/browser/ui/views/side_panel/side_panel_registry.h"
 #include "chrome/browser/ui/views/tabs/recent_activity_bubble_dialog_view.h"
+#if BUILDFLAG(ENABLE_GLIC)
 #include "chrome/browser/ui/views/tabs/tab_strip_action_container.h"
+#endif
 #include "chrome/browser/ui/views/toolbar/chrome_labs/chrome_labs_coordinator.h"
 #include "chrome/browser/ui/views/toolbar/pinned_toolbar_actions_controller.h"
 #include "chrome/browser/ui/views/translate/translate_bubble_controller.h"
@@ -214,6 +216,15 @@ class BrowserWindowFeatures::ExtensionKeybindingRegistryDelegateTabStrip final
 BrowserWindowFeatures::BrowserWindowFeatures() = default;
 BrowserWindowFeatures::~BrowserWindowFeatures() = default;
 
+// static
+bool BrowserWindowFeatures::IsNormalBrowser(const Browser* browser) {
+  // CEF normal browsers have TYPE_POPUP.
+  if (browser->is_type_popup() && browser->cef_delegate()) {
+    return true;
+  }
+  return browser->is_type_normal();
+}
+
 void BrowserWindowFeatures::Init(BrowserWindowInterface* browser) {
   // This is used only for the controllers which will be created on demand
   // later.
@@ -481,6 +492,9 @@ void BrowserWindowFeatures::InitPostWindowConstruction(Browser* browser) {
 #endif
 
   Profile* const profile = browser_->GetProfile();
+
+  const bool supports_toolbar = IsNormalBrowser(browser);
+
   BrowserView* const browser_view =
       BrowserView::GetBrowserViewForBrowser(browser);
   if (browser_view) {
@@ -493,7 +507,7 @@ void BrowserWindowFeatures::InitPostWindowConstruction(Browser* browser) {
   // Features that are only enabled for normal browser windows (e.g. a window
   // with an omnibox and a tab strip). By default most features should be
   // instantiated in this block.
-  if (browser->is_type_normal()) {
+  if (supports_toolbar) {
     if (IsChromeLabsEnabled()) {
       chrome_labs_coordinator_ =
           std::make_unique<ChromeLabsCoordinator>(browser);
@@ -616,7 +630,7 @@ void BrowserWindowFeatures::InitPostWindowConstruction(Browser* browser) {
       browser, browser->GetTabStripModel(), profile, browser->GetWindow(),
       browser->GetType(), browser->app_name(), browser->GetSessionID());
 
-  if (browser->is_type_normal() || browser->is_type_app()) {
+  if (supports_toolbar || browser->is_type_app()) {
     toast_service_ = std::make_unique<ToastService>(browser);
   }
 
@@ -752,7 +766,9 @@ void BrowserWindowFeatures::InitPostBrowserViewConstruction(
       GetUserDataFactory().CreateInstanceWithFactoryMethod(
           *browser_, &chrome::CreateImmersiveModeController, browser_view);
 
-  if (browser_view->GetIsNormalType()) {
+  const bool supports_toolbar = IsNormalBrowser(browser_view->browser());
+
+  if (supports_toolbar) {
 #if BUILDFLAG(ENABLE_GLIC)
     glic::GlicKeyedService* glic_service =
         glic::GlicKeyedService::Get(browser_view->GetProfile());
@@ -817,16 +833,6 @@ void BrowserWindowFeatures::InitPostBrowserViewConstruction(
     }
   }
 
-  if (browser_->GetType() == BrowserWindowInterface::Type::TYPE_NORMAL ||
-      browser_->GetType() == BrowserWindowInterface::Type::TYPE_POPUP ||
-      browser_view->GetIsWebAppType()) {
-    data_protection_ui_controller_ =
-        GetUserDataFactory()
-            .CreateInstance<
-                enterprise_data_protection::DataProtectionUIController>(
-                *browser_view->browser(), browser_view);
-  }
-
 #if !BUILDFLAG(IS_CHROMEOS)
   download_toolbar_ui_controller_ =
       std::make_unique<DownloadToolbarUIController>(browser_view);
@@ -866,6 +872,38 @@ void BrowserWindowFeatures::InitPostBrowserViewConstruction(
       browser_view);
 }
 
+void BrowserWindowFeatures::InitPostTabModelConstruction(
+    BrowserWindowInterface* interface) {
+  auto* browser_view = BrowserView::GetBrowserViewForBrowser(interface);
+  CHECK(browser_view);
+
+  auto* browser = browser_view->browser();
+  const bool supports_toolbar = IsNormalBrowser(browser);
+
+  if (supports_toolbar) {
+    if (!data_protection_ui_controller_) {
+      data_protection_ui_controller_ =
+          GetUserDataFactory()
+              .CreateInstance<
+                  enterprise_data_protection::DataProtectionUIController>(
+                  *browser, browser_view);
+    }
+  }
+}
+
+void BrowserWindowFeatures::OnWebContentsCreated(
+    BrowserWindowInterface* interface,
+    content::WebContents* target_contents) {
+#if BUILDFLAG(ENABLE_CEF)
+  auto* browser_view = BrowserView::GetBrowserViewForBrowser(interface);
+  CHECK(browser_view);
+
+  if (auto cef_delegate = browser_view->browser()->cef_delegate()) {
+    cef_delegate->OnWebContentsCreated(target_contents);
+  }
+#endif
+}
+
 void BrowserWindowFeatures::TearDownPreBrowserWindowDestruction() {
   // Tear down embedder features first, in reverse order of initialization.
   embedder_browser_window_features_->TearDownPreBrowserWindowDestruction();
diff --git chrome/browser/ui/browser_window/public/browser_window_features.h chrome/browser/ui/browser_window/public/browser_window_features.h
index 68fa558078bc5b206fd437d6ccd77f5255cf26e4..ee146377fcf2270136c42d2979b7b9e3dc221352 100644
--- chrome/browser/ui/browser_window/public/browser_window_features.h
+++ chrome/browser/ui/browser_window/public/browser_window_features.h
@@ -147,6 +147,9 @@ namespace chrome {
 class BrowserCommandController;
 }  // namespace chrome
 
+namespace content {
+class WebContents;
+}
 namespace contextual_tasks {
 class ActiveTaskContextProvider;
 class ContextualTasksSidePanelCoordinator;
@@ -229,6 +232,8 @@ class BrowserWindowFeatures {
   BrowserWindowFeatures();
   ~BrowserWindowFeatures();
 
+  static bool IsNormalBrowser(const Browser* browser);
+
   BrowserWindowFeatures(const BrowserWindowFeatures&) = delete;
   BrowserWindowFeatures& operator=(const BrowserWindowFeatures&) = delete;
 
@@ -245,6 +250,16 @@ class BrowserWindowFeatures {
   // hierarchy in BrowserView.
   void InitPostBrowserViewConstruction(BrowserView* browser_view);
 
+  // Initialize features that depend on the tab model object being created. May
+  // be called multiple times (on TabModel ceation via Navigate). With CEF this
+  // will be called after BrowserView construction.
+  void InitPostTabModelConstruction(BrowserWindowInterface* browser);
+
+  // Called when a WebContents is created as part of TabModel ceation via
+  // Navigate.
+  void OnWebContentsCreated(BrowserWindowInterface* browser,
+                            content::WebContents* target_contents);
+
   // Called exactly once to tear down state that depends on the window object.
   void TearDownPreBrowserWindowDestruction();
 
diff --git chrome/browser/ui/browser_window/public/browser_window_interface.h chrome/browser/ui/browser_window/public/browser_window_interface.h
index cc7ad6500dc29ba9280868cf0f78a2b3796a816e..5eabd9010ec904049d44dbf8038be1740ab9b135 100644
--- chrome/browser/ui/browser_window/public/browser_window_interface.h
+++ chrome/browser/ui/browser_window/public/browser_window_interface.h
@@ -315,6 +315,10 @@ class BrowserWindowInterface : public content::PageNavigator {
   // browser window (e.g. most of the 3-dot menu actions).
   virtual BrowserActions* GetActions() = 0;
 
+  // Returns true if this is a normal browser as determined by
+  // BrowserWindowFeatures::IsNormalBrowser.
+  virtual bool IsNormalBrowser() const = 0;
+
   // This is used by features that need to operate on most or all tabs in the
   // browser window. Do not use this method to find a specific tab.
   virtual std::vector<tabs::TabInterface*> GetAllTabInterfaces() = 0;

