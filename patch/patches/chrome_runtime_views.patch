diff --git chrome/browser/ui/browser_command_controller.cc chrome/browser/ui/browser_command_controller.cc
index c9f5fab00a9aa47b5b30d76c65afa500f237ba07..821f9bc4f6d2ba2d2d8b5914f9c726dbc80b2996 100644
--- chrome/browser/ui/browser_command_controller.cc
+++ chrome/browser/ui/browser_command_controller.cc
@@ -533,6 +533,7 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
   // choose to not implement CommandUpdaterDelegate inside this class and
   // therefore command_updater_ doesn't have the delegate set).
   if (!SupportsCommand(id) || !IsCommandEnabled(id)) {
+    LOG(WARNING) << "Invalid/disabled command " << id;
     return false;
   }
 
@@ -550,6 +551,13 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
   DCHECK(command_updater_.IsCommandEnabled(id))
       << "Invalid/disabled command " << id;
 
+#if BUILDFLAG(ENABLE_CEF)
+  if (browser_->cef_delegate() &&
+      browser_->cef_delegate()->HandleCommand(id, disposition)) {
+    return true;
+  }
+#endif
+
   // The order of commands in this switch statement must match the function
   // declaration order in browser.h!
   switch (id) {
@@ -1432,12 +1440,14 @@ void BrowserCommandController::TabRestoreServiceLoaded(
 
 bool BrowserCommandController::IsShowingMainUI() {
   return browser_->SupportsWindowFeature(
-      Browser::WindowFeature::kFeatureTabStrip);
+             Browser::WindowFeature::kFeatureTabStrip) ||
+         browser_->toolbar_overridden();
 }
 
 bool BrowserCommandController::IsShowingLocationBar() {
   return browser_->SupportsWindowFeature(
-      Browser::WindowFeature::kFeatureLocationBar);
+             Browser::WindowFeature::kFeatureLocationBar) ||
+         browser_->toolbar_overridden();
 }
 
 void BrowserCommandController::InitCommandState() {
diff --git chrome/browser/ui/toolbar/app_menu_model.cc chrome/browser/ui/toolbar/app_menu_model.cc
index a688f71a4090c9f65346d0cce723d2a83167bc7e..54e044bdb46973c22a1fdbbf02e8c80674049a83 100644
--- chrome/browser/ui/toolbar/app_menu_model.cc
+++ chrome/browser/ui/toolbar/app_menu_model.cc
@@ -816,10 +816,12 @@ FindAndEditSubMenuModel::FindAndEditSubMenuModel(
     ui::SimpleMenuModel::Delegate* delegate)
     : SimpleMenuModel(delegate) {
   AddItemWithStringIdAndVectorIcon(this, IDC_FIND, IDS_FIND, kSearchMenuIcon);
+  if (delegate->IsCommandIdVisible(IDC_EDIT_MENU)) {
   AddSeparator(ui::NORMAL_SEPARATOR);
   AddItemWithStringIdAndVectorIcon(this, IDC_CUT, IDS_CUT, kCutMenuIcon);
   AddItemWithStringIdAndVectorIcon(this, IDC_COPY, IDS_COPY, kCopyMenuIcon);
   AddItemWithStringIdAndVectorIcon(this, IDC_PASTE, IDS_PASTE, kPasteMenuIcon);
+  }
 }
 
 class SaveAndShareSubMenuModel : public ui::SimpleMenuModel {
@@ -889,6 +891,57 @@ bool ArePromotionsEnabled() {
   return local_state && local_state->GetBoolean(prefs::kPromotionsEnabled);
 }
 
+#if BUILDFLAG(ENABLE_CEF)
+using IsVisibleCallback = base::RepeatingCallback<bool(int)>;
+
+void FilterMenuModel(ui::SimpleMenuModel* model,
+                     const IsVisibleCallback& is_visible) {
+  std::optional<size_t> last_separator;
+  size_t visible_ct = 0;
+  for (size_t i = 0; i < model->GetItemCount(); ++i) {
+    const auto type = model->GetTypeAt(i);
+    if (type == ui::MenuModel::TYPE_SEPARATOR) {
+      if (last_separator) {
+        // Remove multiple separators in a row. Prefer to remove a NORMAL
+        // separator if possible (as compared to zoom/edit controls which use
+        // UPPER/LOWER separators).
+        if (model->GetSeparatorTypeAt(*last_separator) ==
+            ui::NORMAL_SEPARATOR) {
+          model->RemoveItemAt(*last_separator);
+          i--;
+          last_separator = i;
+        } else {
+          model->RemoveItemAt(i);
+          i--;
+        }
+      } else if (visible_ct == 0) {
+        // Remove leading separator.
+        model->RemoveItemAt(i);
+        i--;
+      } else {
+        last_separator = i;
+      }
+      visible_ct = 0;
+    } else if (is_visible.Run(model->GetCommandIdAt(i))) {
+      last_separator = std::nullopt;
+      visible_ct++;
+
+      if (type == ui::MenuModel::TYPE_SUBMENU) {
+        // Filter sub-menu.
+        auto sub_model =
+            static_cast<ui::SimpleMenuModel*>(model->GetSubmenuModelAt(i));
+        FilterMenuModel(sub_model, is_visible);
+      }
+    }
+  }
+
+  if (last_separator) {
+    // Remove trailing separator.
+    model->RemoveItemAt(*last_separator);
+  }
+}
+#endif  // BUILDFLAG(ENABLE_CEF)
+
 }  // namespace
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1861,7 +1914,7 @@ bool AppMenuModel::IsCommandIdChecked(int command_id) const {
   return false;
 }
 
-bool AppMenuModel::IsCommandIdEnabled(int command_id) const {
+bool AppMenuModel::IsCommandIdEnabledInternal(int command_id) const {
   GlobalError* error =
       GlobalErrorServiceFactory::GetForProfile(browser_->profile())
           ->GetGlobalErrorByMenuItemCommandID(command_id);
@@ -1877,6 +1930,30 @@ bool AppMenuModel::IsCommandIdEnabled(int command_id) const {
   }
 }
 
+bool AppMenuModel::IsCommandIdEnabled(int command_id) const {
+  if (!IsCommandIdEnabledInternal(command_id)) {
+    return false;
+  }
+
+#if BUILDFLAG(ENABLE_CEF)
+  if (browser_->cef_delegate()) {
+    return browser_->cef_delegate()->IsAppMenuItemEnabled(command_id);
+  }
+#endif
+
+  return true;
+}
+
+bool AppMenuModel::IsCommandIdVisible(int command_id) const {
+#if BUILDFLAG(ENABLE_CEF)
+  if (browser_->cef_delegate()) {
+    return browser_->cef_delegate()->IsAppMenuItemVisible(command_id);
+  }
+#endif
+
+  return true;
+}
+
 bool AppMenuModel::IsCommandIdAlerted(int command_id) const {
   if (command_id == IDC_VIEW_PASSWORDS ||
       command_id == IDC_SHOW_PASSWORD_MANAGER) {
@@ -2058,8 +2135,10 @@ void AppMenuModel::Build() {
                                    IDS_CLEAR_BROWSING_DATA,
                                    kTrashCanRefreshIcon);
 
+  if (IsCommandIdVisible(IDC_ZOOM_MENU)) {
   AddSeparator(ui::NORMAL_SEPARATOR);
   CreateZoomMenu();
+  }
   AddSeparator(ui::NORMAL_SEPARATOR);
 
   AddItemWithStringIdAndVectorIcon(this, IDC_PRINT, IDS_PRINT, kPrintMenuIcon);
@@ -2173,6 +2252,11 @@ void AppMenuModel::Build() {
   }
 #endif  // !BUILDFLAG(IS_CHROMEOS)
 
+#if BUILDFLAG(ENABLE_CEF)
+  FilterMenuModel(this, base::BindRepeating(&AppMenuModel::IsCommandIdVisible,
+                                            base::Unretained(this)));
+#endif
+
   uma_action_recorded_ = false;
 }
 
diff --git chrome/browser/ui/toolbar/app_menu_model.h chrome/browser/ui/toolbar/app_menu_model.h
index 673a1bf2acb2467aa3ac5746c4d6193fba8487f2..121986d07d325c7d628c431733a104a845ba97ac 100644
--- chrome/browser/ui/toolbar/app_menu_model.h
+++ chrome/browser/ui/toolbar/app_menu_model.h
@@ -239,6 +239,7 @@ class AppMenuModel : public ui::SimpleMenuModel,
   void ExecuteCommand(int command_id, int event_flags) override;
   bool IsCommandIdChecked(int command_id) const override;
   bool IsCommandIdEnabled(int command_id) const override;
+  bool IsCommandIdVisible(int command_id) const override;
   bool IsCommandIdAlerted(int command_id) const override;
   bool GetAcceleratorForCommandId(int command_id,
                                   ui::Accelerator* accelerator) const override;
@@ -278,6 +279,8 @@ class AppMenuModel : public ui::SimpleMenuModel,
   void LogSafetyHubInteractionMetrics(safety_hub::SafetyHubModuleType sh_module,
                                       int event_flags);
 
+  bool IsCommandIdEnabledInternal(int command_id) const;
+
  private:
   // Adds actionable global error menu items to the menu.
   // Examples: Extension permissions and sign in errors.
diff --git chrome/browser/ui/views/frame/browser_view.cc chrome/browser/ui/views/frame/browser_view.cc
index 1596366892e11ff1d48cf0984d36adf15ffd9ac5..93e46c35f6a58e80147ac6334de92073b00be91a 100644
--- chrome/browser/ui/views/frame/browser_view.cc
+++ chrome/browser/ui/views/frame/browser_view.cc
@@ -850,13 +850,23 @@ class BrowserView::AccessibilityModeObserver : public ui::AXModeObserver {
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, public:
 
+BrowserView::BrowserView() : BrowserView(nullptr) {}
+
 BrowserView::BrowserView(Browser* browser)
     : views::ClientView(nullptr, nullptr),
       exclusive_access_context_(
           std::make_unique<ExclusiveAccessContextImpl>(*this)),
-      browser_(browser),
       accessibility_mode_observer_(
           std::make_unique<AccessibilityModeObserver>(this)) {
+  if (browser) {
+    InitBrowser(browser);
+  }
+}
+
+void BrowserView::InitBrowser(Browser* browser) {
+  DCHECK(!browser_);
+  browser_ = browser;
+
   if (auto* manager = InitialWebUIWindowMetricsManager::From(browser_.get())) {
     manager->OnBrowserWindowCreated();
   }
@@ -875,7 +885,7 @@ BrowserView::BrowserView(Browser* browser)
     SetCanMinimize(false);
     SetCanMaximize(false);
     SetCanFullscreen(false);
-    SetCanResize(true);
+    SetCanResize(browser_->create_params().can_resize);
   } else {
     SetCanResize(browser_->create_params().can_resize);
     SetCanMaximize(browser_->create_params().can_maximize);
@@ -922,8 +932,15 @@ BrowserView::BrowserView(Browser* browser)
   contents_container->SetLayoutManager(std::make_unique<ContentsLayoutManager>(
       contents_view, lens_overlay_view_));
 
-  toolbar_ = top_container_->AddChildView(
-      std::make_unique<ToolbarView>(browser_.get(), this));
+  toolbar_ = OverrideCreateToolbar();
+  if (!toolbar_) {
+    toolbar_ = new ToolbarView(browser_.get(), this, std::nullopt);
+  } else {
+    browser_->set_toolbar_overridden(true);
+    // Update state that depends on the above flag.
+    browser_->command_controller()->FullscreenStateChanged();
+  }
+  top_container_->AddChildView(base::WrapUnique(toolbar_.get()));
 
   top_container_separator_ = top_container_->AddChildView(
       ContentsSeparator::CreateContentsSeparator());
@@ -1033,6 +1050,10 @@ BrowserView::BrowserView(Browser* browser)
 }
 
 BrowserView::~BrowserView() {
+  // If the Toolbar is not overloaded it will be destroyed via
+  // RemoveAllChildViews().
+  WillDestroyToolbar();
+
   // Remove the layout manager to avoid dangling. This needs to be earlier than
   // other cleanups that destroy views referenced in the layout manager.
   SetLayoutManager(nullptr);
@@ -1045,7 +1066,9 @@ BrowserView::~BrowserView() {
 
   // All the tabs should have been destroyed already. If we were closed by the
   // OS with some tabs than the BrowserNativeWidget should have destroyed them.
-  DCHECK_EQ(0, browser_->tab_strip_model()->count());
+  if (browser_) {
+    DCHECK_EQ(0, browser_->tab_strip_model()->count());
+  }
 
   // Stop the animation timer explicitly here to avoid running it in a nested
   // message loop, which may run by Browser destructor.
@@ -1140,7 +1163,7 @@ void BrowserView::SetDisableRevealerDelayForTesting(bool disable) {
   g_disable_revealer_delay_for_testing = disable;
 }
 
-gfx::Rect BrowserView::GetFindBarBoundingBox() const {
+gfx::Rect BrowserView::GetFindBarBoundingBoxImpl() const {
   gfx::Rect contents_bounds = contents_container_->ConvertRectToWidget(
       contents_container_->GetLocalBounds());
 
@@ -1162,6 +1185,16 @@ gfx::Rect BrowserView::GetFindBarBoundingBox() const {
   return contents_container_->GetMirroredRect(contents_bounds);
 }
 
+gfx::Rect BrowserView::GetFindBarBoundingBox() const {
+  auto bounds = GetFindBarBoundingBoxImpl();
+#if BUILDFLAG(ENABLE_CEF)
+  if (browser() && browser()->cef_delegate()) {
+    browser()->cef_delegate()->UpdateFindBarBoundingBox(&bounds);
+  }
+#endif
+  return bounds;
+}
+
 int BrowserView::GetTabStripHeight() const {
   // We want to return tabstrip_->height(), but we might be called in the midst
   // of layout, when that hasn't yet been updated to reflect the current state.
@@ -1782,6 +1815,28 @@ gfx::Point BrowserView::GetThemeOffsetFromBrowserView() const {
       ThemeProperties::kFrameHeightAboveTabs - browser_view_origin.y());
 }
 
+void BrowserView::WillDestroyToolbar() {
+  // Reset autofill bubble handler to make sure it does not out-live toolbar,
+  // since it is responsible for showing autofill related bubbles from toolbar's
+  // child views and it is an observer for avatar toolbar button if any.
+  autofill_bubble_handler_.reset();
+
+  toolbar_button_provider_ = nullptr;
+  if (GetBrowserViewLayout()) {
+    GetBrowserViewLayout()->reset_toolbar();
+  }
+
+  if (toolbar_ && toolbar_->parent()) {
+    // Remove now instead of waiting for RemoveAllChildViews(), as there is
+    // otherwise no guarantee that the Toolbar will be removed before the
+    // BrowserView is removed (and destroyed).
+    toolbar_->parent()->RemoveChildView(toolbar_);
+    toolbar_.ClearAndDelete();
+  } else {
+    toolbar_ = nullptr;
+  }
+}
+
 bool BrowserView::IsLoadingAnimationRunning() const {
   return loading_animation_timer_.IsRunning();
 }
@@ -2091,7 +2146,11 @@ void BrowserView::Restore() {
 
 bool BrowserView::ShouldHideUIForFullscreen() const {
   // Immersive mode needs UI for the slide-down top panel.
-  if (ImmersiveModeController::From(browser())->IsEnabled()) {
+  // Avoid callback into |immersive_mode_controller| during construction.
+  // See CEF issue #3527.
+  auto* const immersive_mode_controller =
+      ImmersiveModeController::From(browser());
+  if (immersive_mode_controller && immersive_mode_controller->IsEnabled()) {
     return false;
   }
 
@@ -3269,6 +3328,9 @@ void BrowserView::ShowOneClickSigninConfirmation(
 
 DownloadBubbleUIController* BrowserView::GetDownloadBubbleUIController() {
 #if !BUILDFLAG(IS_CHROMEOS)
+  if (!browser_) {
+    return nullptr;
+  }
   if (auto* download_controller =
           browser_->GetFeatures().download_toolbar_ui_controller()) {
     return download_controller->bubble_controller();
@@ -4316,7 +4378,10 @@ bool BrowserView::GetSavedWindowPlacement(
 }
 
 views::View* BrowserView::GetContentsView() {
-  return multi_contents_view_->GetActiveContentsView();
+  if (multi_contents_view_) {
+    return multi_contents_view_->GetActiveContentsView();
+  }
+  return nullptr;
 }
 
 views::ClientView* BrowserView::CreateClientView(views::Widget* widget) {
@@ -4495,9 +4560,22 @@ void BrowserView::DeleteBrowserWindow() {
   // before the frame is destroyed to mitigate UAF risk.
   browser_widget_->SaveWindowPlacementIfNeeded();
 
-  browser_widget_.reset();
-  // BrowserWidget owns BrowserView in its views::View hierarchy and `this` will
-  // not be valid after this returns.
+  const bool views_hosted =
+#if BUILDFLAG(ENABLE_CEF)
+      browser() && browser()->cef_delegate() &&
+      browser()->cef_delegate()->IsViewsHosted();
+#else
+      false;
+#endif
+
+  if (views_hosted) {
+    // The BrowserWidget is owned by CefWindowWidgetDelegate.
+    browser_widget_.release();
+  } else {
+    browser_widget_.reset();
+    // BrowserWidget owns BrowserView in its views::View hierarchy and `this`
+    // will not be valid after this returns.
+  }
 }
 
 void BrowserView::SetForceShowBookmarkBarFlag(
@@ -4790,11 +4868,36 @@ void BrowserView::GetAccessiblePanes(std::vector<views::View*>* panes) {
 bool BrowserView::ShouldDescendIntoChildForEventHandling(
     gfx::NativeView child,
     const gfx::Point& location) {
+#if BUILDFLAG(ENABLE_CEF)
+  const bool frameless_pip =
+      GetIsPictureInPictureType() &&
+      !browser_->SupportsWindowFeature(Browser::WindowFeature::kFeatureTitleBar);
+  if (frameless_pip) {
+    int result = GetFrameView()->NonClientHitTest(location);
+    if (result == HTTOP || result == HTTOPLEFT || result == HTTOPRIGHT) {
+      // Allow resize from the top of a frameless window.
+      return false;
+    }
+  }
+#endif
+
+  std::optional<SkRegion> draggable_region;
+
   // Window for PWAs with window-controls-overlay display override should claim
   // mouse events that fall within the draggable region.
   web_app::AppBrowserController* controller = browser()->app_controller();
-  if (AreDraggableRegionsEnabled() && controller &&
-      controller->draggable_region().has_value()) {
+  if (AreDraggableRegionsEnabled() && controller) {
+    draggable_region = controller->draggable_region();
+  }
+
+#if BUILDFLAG(ENABLE_CEF)
+  // Match logic in PictureInPictureBrowserFrameView::NonClientHitTest.
+  if (!draggable_region.has_value() && frameless_pip) {
+    draggable_region = browser_->cef_delegate()->GetDraggableRegion();
+  }
+#endif
+
+  if (draggable_region.has_value()) {
     // Draggable regions are defined relative to the web contents.
     gfx::Point point_in_contents_web_view_coords(location);
     views::View::ConvertPointToTarget(GetWidget()->GetRootView(),
@@ -4803,9 +4906,8 @@ bool BrowserView::ShouldDescendIntoChildForEventHandling(
 
     // Draggable regions should be ignored for clicks into any browser view's
     // owned widgets, for example alerts, permission prompts or find bar.
-    return !controller->draggable_region()->contains(
-               point_in_contents_web_view_coords.x(),
-               point_in_contents_web_view_coords.y()) ||
+    return !draggable_region->contains(point_in_contents_web_view_coords.x(),
+                                       point_in_contents_web_view_coords.y()) ||
            WidgetOwnedByAnchorContainsPoint(point_in_contents_web_view_coords);
   }
 
@@ -5077,7 +5179,9 @@ void BrowserView::Layout(PassKey) {
 
   // TODO(jamescook): Why was this in the middle of layout code?
   toolbar_->location_bar()->omnibox_view()->SetFocusBehavior(
-      IsToolbarVisible() ? FocusBehavior::ALWAYS : FocusBehavior::NEVER);
+      (IsToolbarVisible() || browser_->toolbar_overridden())
+          ? FocusBehavior::ALWAYS
+          : FocusBehavior::NEVER);
   GetFrameView()->UpdateMinimumSize();
 
   // Some of the situations when the BrowserView is laid out are:
@@ -5168,6 +5272,12 @@ void BrowserView::AddedToWidget() {
   SetThemeProfileForWindow(GetNativeWindow(), browser_->GetProfile());
 #endif
 
+  // This browser view may already have a custom button provider set (e.g the
+  // hosted app frame).
+  if (!toolbar_button_provider_) {
+    SetToolbarButtonProvider(toolbar_);
+  }
+
   toolbar_->Init();
 
   UpdateTabSearchBubbleHost();
@@ -5262,12 +5372,6 @@ void BrowserView::AddedToWidget() {
 
   EnsureFocusOrder();
 
-  // This browser view may already have a custom button provider set (e.g the
-  // hosted app frame).
-  if (!toolbar_button_provider_) {
-    SetToolbarButtonProvider(toolbar_);
-  }
-
 #if !BUILDFLAG(IS_CHROMEOS)
   browser_->GetFeatures().download_toolbar_ui_controller()->Init();
 #endif
@@ -5308,6 +5412,13 @@ void BrowserView::AddedToWidget() {
   dialog_anchor_ = std::make_unique<user_education::ViewSubregionAnchor>(
       kBrowserDialogAnchorElementId, *this);
 
+  if (browser_->window()) {
+    // Initialize the browser features that rely on the browser window now that
+    // it is initialized. This will instead be called from the Browser
+    // constructor for default Chrome UI windows.
+    browser_->GetFeatures().InitPostWindowConstruction(browser_.get());
+  }
+
   initialized_ = true;
 }
 
diff --git chrome/browser/ui/views/frame/browser_view.h chrome/browser/ui/views/frame/browser_view.h
index 4a97092cabdaad51fba95f169d3edeb7f4f19344..408218116d484b4bc0bed98d989aba3bd670259e 100644
--- chrome/browser/ui/views/frame/browser_view.h
+++ chrome/browser/ui/views/frame/browser_view.h
@@ -148,7 +148,9 @@ class BrowserView : public BrowserWindow,
   // locate this object using just the handle.
   static constexpr char kBrowserViewKey[] = "__BROWSER_VIEW__";
 
+  BrowserView();
   explicit BrowserView(Browser* browser);
+  void InitBrowser(Browser* browser);
   BrowserView(const BrowserView&) = delete;
   BrowserView& operator=(const BrowserView&) = delete;
   ~BrowserView() override;
@@ -874,10 +876,16 @@ class BrowserView : public BrowserWindow,
   bool IsLockedFullscreen() const;
 #endif
 
- protected:
+  // Called during Toolbar destruction to remove dependent objects that have
+  // dangling references.
+  virtual void WillDestroyToolbar();
+
   // BrowserWindow:
   void DeleteBrowserWindow() final;
 
+ protected:
+  virtual ToolbarView* OverrideCreateToolbar() { return nullptr; }
+
  private:
   // Do not friend BrowserViewLayout. Use the BrowserViewLayoutDelegate
   // interface to keep these two classes decoupled and testable.
@@ -1155,11 +1163,13 @@ class BrowserView : public BrowserWindow,
   class ExclusiveAccessContextImpl;
   std::unique_ptr<ExclusiveAccessContextImpl> exclusive_access_context_;
 
+  gfx::Rect GetFindBarBoundingBoxImpl() const;
+
   // The BrowserWidget that owns this view.
   std::unique_ptr<BrowserWidget> browser_widget_;
 
   // The owning Browser object. `browser_` will outlive this.
-  const raw_ptr<Browser> browser_;
+  raw_ptr<Browser> browser_;
 
   base::CallbackListSubscription chip_visibility_subscription_;
 
diff --git chrome/browser/ui/views/frame/browser_widget.cc chrome/browser/ui/views/frame/browser_widget.cc
index 488fd24b386f934f01461982455f1efcdcc45a74..2f05ec41112e9692976e09dfcd6b36635b2e0ea7 100644
--- chrome/browser/ui/views/frame/browser_widget.cc
+++ chrome/browser/ui/views/frame/browser_widget.cc
@@ -112,14 +112,27 @@ ui::ColorProviderKey::SchemeVariant GetSchemeVariant(
 ////////////////////////////////////////////////////////////////////////////////
 // BrowserWidget, public:
 
+BrowserWidget::BrowserWidget() : BrowserWidget(nullptr) {}
+
 BrowserWidget::BrowserWidget(BrowserView* browser_view)
     : browser_native_widget_(nullptr),
       root_view_(nullptr),
       browser_frame_view_(nullptr),
-      browser_view_(browser_view) {
+      browser_view_(nullptr) {
   set_is_secondary_widget(false);
   // Don't focus anything on creation, selecting a tab will set the focus.
   set_focus_on_creation(false);
+  if (browser_view) {
+    SetBrowserView(browser_view);
+  }
+}
+
+void BrowserWidget::SetBrowserFrameView(BrowserFrameView* browser_frame_view) {
+  browser_frame_view_ = browser_frame_view;
+}
+
+void BrowserWidget::SetBrowserView(BrowserView* browser_view) {
+  browser_view_ = browser_view;
 }
 
 BrowserWidget::~BrowserWidget() {
@@ -140,7 +153,11 @@ BrowserWidget::~BrowserWidget() {
   // Do this here and not in ~BrowserView() as BrowserWindowFeatures may attempt
   // to read state on the BrowserWidget as they undergo destruction, and
   // BrowserWidget state is destroyed at the end of this scope.
-  browser_view_->browser()->GetFeatures().TearDownPreBrowserWindowDestruction();
+  if (browser_view_ && browser_view_->browser()) {
+    browser_view_->browser()
+        ->GetFeatures()
+        .TearDownPreBrowserWindowDestruction();
+  }
 }
 
 void BrowserWidget::InitBrowserWidget() {
@@ -229,6 +246,8 @@ void BrowserWidget::GetWindowPlacement(
     ui::mojom::WindowShowState* show_state) const {
   if (browser_native_widget_) {
     browser_native_widget_->GetWindowPlacement(bounds, show_state);
+  } else {
+    *show_state = ui::mojom::WindowShowState::kDefault;
   }
 }
 
@@ -339,6 +358,9 @@ ui::ColorProviderKey::ThemeInitializerSupplier* BrowserWidget::GetCustomTheme()
 }
 
 void BrowserWidget::OnNativeWidgetWorkspaceChanged() {
+  if (!browser_view_) {
+    return;
+  }
   chrome::SaveWindowWorkspace(browser_view_->browser(), GetWorkspace());
   chrome::SaveWindowVisibleOnAllWorkspaces(browser_view_->browser(),
                                            IsVisibleOnAllWorkspaces());
@@ -550,6 +572,13 @@ void BrowserWidget::SelectNativeTheme() {
     return;
   }
 
+  // Always use the NativeTheme for forced color modes.
+  if (ui::NativeTheme::IsForcedDarkMode() ||
+      ui::NativeTheme::IsForcedLightMode()) {
+    SetNativeTheme(native_theme);
+    return;
+  }
+
   // Ignore the system theme for web apps with window-controls-overlay as the
   // display_override so the web contents can blend with the overlay by using
   // the developer-provided theme color for a better experience. Context:
@@ -566,15 +595,17 @@ void BrowserWidget::SelectNativeTheme() {
 void BrowserWidget::OnTouchUiChanged() {
   client_view()->InvalidateLayout();
 
-  // For standard browser frame, if we do not invalidate the FrameView
-  // the client window bounds will not be properly updated which could cause
-  // visual artifacts. See crbug.com/1035959 for details.
-  if (non_client_view()->frame_view()) {
-    // Note that invalidating a view invalidates all of its ancestors, so it is
-    // not necessary to also invalidate the NonClientView or RootView here.
-    non_client_view()->frame_view()->InvalidateLayout();
-  } else {
-    non_client_view()->InvalidateLayout();
+  if (non_client_view()) {
+    // For standard browser frame, if we do not invalidate the FrameView
+    // the client window bounds will not be properly updated which could cause
+    // visual artifacts. See crbug.com/1035959 for details.
+    if (non_client_view()->frame_view()) {
+      // Note that invalidating a view invalidates all of its ancestors, so it
+      // is not necessary to also invalidate the NonClientView or RootView here.
+      non_client_view()->frame_view()->InvalidateLayout();
+    } else {
+      non_client_view()->InvalidateLayout();
+    }
   }
   GetRootView()->InvalidateLayout();
 }
@@ -615,5 +646,8 @@ bool BrowserWidget::RegenerateFrameOnThemeChange(
 }
 
 bool BrowserWidget::IsIncognitoBrowser() const {
+  if (!browser_view_) {
+    return true;
+  }
   return browser_view_->browser()->profile()->IsIncognitoProfile();
 }
diff --git chrome/browser/ui/views/frame/browser_widget.h chrome/browser/ui/views/frame/browser_widget.h
index 470e63b9352a1641cab22f416810eec7cbc03ad9..9c22ace412038b437160bd691c395decba9b94e0 100644
--- chrome/browser/ui/views/frame/browser_widget.h
+++ chrome/browser/ui/views/frame/browser_widget.h
@@ -58,6 +58,7 @@ enum class TabDragKind {
 class BrowserWidget : public views::Widget,
                       public views::ContextMenuController {
  public:
+  BrowserWidget();
   explicit BrowserWidget(BrowserView* browser_view);
 
   BrowserWidget(const BrowserWidget&) = delete;
@@ -98,7 +99,7 @@ class BrowserWidget : public views::Widget,
 
   // ThemeService calls this when a user has changed their theme, indicating
   // that it's time to redraw everything.
-  void UserChangedTheme(BrowserThemeChangeType theme_change_type);
+  virtual void UserChangedTheme(BrowserThemeChangeType theme_change_type);
 
   // views::Widget:
   views::internal::RootView* CreateRootView() override;
@@ -132,22 +133,27 @@ class BrowserWidget : public views::Widget,
   void SetTabDragKind(TabDragKind tab_drag_kind);
   TabDragKind tab_drag_kind() const { return tab_drag_kind_; }
 
+  BrowserView* browser_view() const { return browser_view_.get(); }
+
  protected:
+  void SetBrowserFrameView(BrowserFrameView* browser_frame_view);
+  void SetBrowserView(BrowserView* browser_view);
+
   // views::Widget:
   void OnNativeThemeUpdated(ui::NativeTheme* observed_theme) override;
   ui::ColorProviderKey GetColorProviderKey() const override;
 
+  // Select a native theme that is appropriate for the current context. This is
+  // currently only needed for Linux to switch between the regular NativeTheme
+  // and the GTK NativeTheme instance.
+  void SelectNativeTheme();
+
  private:
   void OnTouchUiChanged();
 
   // Callback for MenuRunner.
   void OnMenuClosed();
 
-  // Select a native theme that is appropriate for the current context. This is
-  // currently only needed for Linux to switch between the regular NativeTheme
-  // and the GTK NativeTheme instance.
-  void SelectNativeTheme();
-
   // Regenerate the frame on theme change if necessary. Returns true if
   // regenerated.
   bool RegenerateFrameOnThemeChange(BrowserThemeChangeType theme_change_type);
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout.cc chrome/browser/ui/views/frame/layout/browser_view_layout.cc
index ebe0e2d5962404d48d9f25a37448c374dff93cd4..c294aaa9f0b444eda91fa84c6e62119c18de7436 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout.cc
+++ chrome/browser/ui/views/frame/layout/browser_view_layout.cc
@@ -23,6 +23,10 @@
 #include "ui/views/widget/widget.h"
 #include "ui/views/widget/widget_observer.h"
 
+#if BUILDFLAG(ENABLE_CEF)
+#include "cef/libcef/browser/chrome/views/chrome_views_util.h"
+#endif
+
 using web_modal::ModalDialogHostObserver;
 using web_modal::WebContentsModalDialogHost;
 
@@ -56,6 +60,8 @@ class BrowserViewLayout::BrowserModalDialogHostViews
     observer_list_.Notify(&ModalDialogHostObserver::OnHostDestroying);
   }
 
+  bool HasObservers() const { return !observer_list_.empty(); }
+
   void NotifyPositionRequiresUpdate() {
     observer_list_.Notify(&ModalDialogHostObserver::OnPositionRequiresUpdate);
   }
@@ -212,18 +218,21 @@ void BrowserViewLayout::UpdateBubbles() {
     exclusive_access_bubble->RepositionIfVisible();
   }
 
-  // Adjust any hosted dialogs if the browser's dialog hosting bounds changed.
-  const gfx::Rect dialog_bounds(dialog_host_->GetDialogPosition(gfx::Size()),
-                                dialog_host_->GetMaximumDialogSize());
-  const gfx::Rect host_widget_bounds =
-      dialog_host_->GetHostWidget()
-          ? dialog_host_->GetHostWidget()->GetClientAreaBoundsInScreen()
-          : gfx::Rect();
-  const gfx::Rect dialog_bounds_in_screen =
-      dialog_bounds + host_widget_bounds.OffsetFromOrigin();
-  if (latest_dialog_bounds_in_screen_ != dialog_bounds_in_screen) {
-    latest_dialog_bounds_in_screen_ = dialog_bounds_in_screen;
-    dialog_host_->NotifyPositionRequiresUpdate();
+  // Avoid unnecessary calls to UpdateDialogTopInsetInBrowserView().
+  if (dialog_host_->HasObservers()) {
+    // Adjust any hosted dialogs if the browser's dialog hosting bounds changed.
+    const gfx::Rect dialog_bounds(dialog_host_->GetDialogPosition(gfx::Size()),
+                                  dialog_host_->GetMaximumDialogSize());
+    const gfx::Rect host_widget_bounds =
+        dialog_host_->GetHostWidget()
+            ? dialog_host_->GetHostWidget()->GetClientAreaBoundsInScreen()
+            : gfx::Rect();
+    const gfx::Rect dialog_bounds_in_screen =
+        dialog_bounds + host_widget_bounds.OffsetFromOrigin();
+    if (latest_dialog_bounds_in_screen_ != dialog_bounds_in_screen) {
+      latest_dialog_bounds_in_screen_ = dialog_bounds_in_screen;
+      dialog_host_->NotifyPositionRequiresUpdate();
+    }
   }
 }
 
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout.h chrome/browser/ui/views/frame/layout/browser_view_layout.h
index dc8e48a830e7d8bb49df36ae31379bf11a508e6d..47bad1101a4d37c13a2ee4f6f82dc6a126770b72 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout.h
+++ chrome/browser/ui/views/frame/layout/browser_view_layout.h
@@ -126,6 +126,8 @@ class BrowserViewLayout : public views::LayoutManager {
     return views_.side_panel_animation_content;
   }
 
+  void reset_toolbar() { views_.toolbar = nullptr; }
+
   // views::LayoutManager overrides:
   gfx::Size GetPreferredSize(
       const views::View* host,
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_delegate.h chrome/browser/ui/views/frame/layout/browser_view_layout_delegate.h
index c18f56560a3a53ac62a2e16764ece40f7c644c81..afb236f69361d45751325f12994e89f7c228870e 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_delegate.h
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_delegate.h
@@ -43,6 +43,7 @@ class BrowserViewLayoutDelegate {
       views::Label& window_title_label) const = 0;
   virtual views::LayoutAlignment GetWindowTitleAlignment() const = 0;
   virtual int GetTopInsetInBrowserView() const = 0;
+  virtual void UpdateDialogTopInsetInBrowserView(int* dialog_top_y) const = 0;
   virtual bool IsToolbarVisible() const = 0;
   virtual bool IsBookmarkBarVisible() const = 0;
   virtual bool IsInfobarVisible() const = 0;
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.cc chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.cc
index 010596c2e5f56b088fcb97f5a8d1ae78396c6b06..e6cb72fcd3116c35d62c5278768ad73fafabb180 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.cc
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.cc
@@ -95,6 +95,15 @@ int BrowserViewLayoutDelegateImpl::GetTopInsetInBrowserView() const {
   return 0;
 }
 
+void BrowserViewLayoutDelegateImpl::UpdateDialogTopInsetInBrowserView(
+    int* dialog_top_y) const {
+#if BUILDFLAG(ENABLE_CEF)
+  if (auto cef_delegate = browser_view_->browser()->cef_delegate()) {
+    cef_delegate->UpdateDialogTopInset(dialog_top_y);
+  }
+#endif
+}
+
 void BrowserViewLayoutDelegateImpl::LayoutWebAppWindowTitle(
     const gfx::Rect& available_space,
     views::Label& window_title_label) const {
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.h chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.h
index e12cbe490e91fd694cf6205ce8c7393160d5c9f3..1d2b765289e6900758338a43f35d7a762163b587 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.h
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_delegate_impl.h
@@ -32,6 +32,7 @@ class BrowserViewLayoutDelegateImpl : public BrowserViewLayoutDelegate {
   BrowserLayoutParams GetBrowserLayoutParams(
       bool use_browser_bounds) const override;
   int GetTopInsetInBrowserView() const override;
+  void UpdateDialogTopInsetInBrowserView(int* dialog_top_y) const override;
   void LayoutWebAppWindowTitle(const gfx::Rect& available_space,
                                views::Label& window_title_label) const override;
   views::LayoutAlignment GetWindowTitleAlignment() const override;
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_impl.cc chrome/browser/ui/views/frame/layout/browser_view_layout_impl.cc
index f5a132ca1a137a8c022281f4fcd64be98046abc9..a21b43f4e99b09f325a6431f3bd7e4ed15a3a415 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_impl.cc
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_impl.cc
@@ -207,10 +207,18 @@ int BrowserViewLayoutImpl::GetMinWebContentsWidthForTesting() const {
 // Layout logic.
 
 void BrowserViewLayoutImpl::Layout(views::View* host) {
-  const auto params =
-      delegate().GetBrowserLayoutParams(/*use_browser_bounds=*/true);
+  auto params = delegate().GetBrowserLayoutParams(/*use_browser_bounds=*/true);
   if (params.IsEmpty()) {
-    return;
+    // Layout params are empty during early initialization (before the frame
+    // view has been laid out). Fall back to using the host's local bounds
+    // as the visual client area to allow layout to proceed with valid bounds.
+    // This prevents View::Layout's for-loop from triggering child layouts
+    // with 0x0 bounds.
+    params.visual_client_area = host->GetLocalBounds();
+    if (params.IsEmpty()) {
+      // Host also has no bounds yet, can't perform layout.
+      return;
+    }
   }
 
   // Lay out the browser view itself.
@@ -282,11 +290,13 @@ void BrowserViewLayoutImpl::Layout(views::View* host) {
 int BrowserViewLayoutImpl::GetDialogTop(const ProposedLayout& layout) const {
   const int kConstrainedWindowOverlap = 3;
   const auto* const browser_view = views().browser_view.get();
+  int dialog_top_y = kConstrainedWindowOverlap;
   if (const auto toolbar_rect =
           layout.GetBoundsFor(views().toolbar, browser_view)) {
-    return toolbar_rect->bottom() - kConstrainedWindowOverlap;
+    dialog_top_y = toolbar_rect->bottom() - kConstrainedWindowOverlap;
   }
-  return kConstrainedWindowOverlap;
+  delegate().UpdateDialogTopInsetInBrowserView(&dialog_top_y);
+  return dialog_top_y;
 }
 
 int BrowserViewLayoutImpl::GetDialogBottom(const ProposedLayout& layout) const {
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc
index d6253f848ee67ca1e81dd97639573f337de789a0..90676b92eb596e5b30c6359f2f6add0cbf4a2a83 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc
@@ -30,6 +30,10 @@
 #include "chrome/browser/ui/fullscreen_util_mac.h"
 #endif
 
+#if BUILDFLAG(ENABLE_CEF)
+#include "cef/libcef/browser/chrome/views/chrome_views_util.h"
+#endif
+
 namespace {
 
 // The number of pixels the constrained window should overlap the bottom
@@ -410,6 +414,15 @@ void BrowserViewLayoutImplOld::LayoutWebUITabStrip(
 
 void BrowserViewLayoutImplOld::LayoutToolbar(gfx::Rect& available_bounds) {
   TRACE_EVENT0("ui", "BrowserViewLayout::LayoutToolbar");
+
+#if BUILDFLAG(ENABLE_CEF)
+  if (cef::IsCefView(views().toolbar)) {
+    // CEF may take ownership of the toolbar. Early exit to avoid the DCHECK
+    // in LayoutManager::SetViewVisibility().
+    return;
+  }
+#endif
+
   bool toolbar_visible = delegate().IsToolbarVisible();
   SetViewVisibility(views().toolbar, toolbar_visible);
 
@@ -663,7 +676,7 @@ gfx::Point BrowserViewLayoutImplOld::GetDialogPosition(
   }
   const int middle_x =
       leading_x + layout_result.contents_container_bounds.width() / 2;
-  return gfx::Point(middle_x - dialog_size.width() / 2, dialog_top_y_);
+  return gfx::Point(middle_x - dialog_size.width() / 2, GetDialogTopY());
 }
 
 gfx::Size BrowserViewLayoutImplOld::GetMaximumDialogSize() const {
@@ -677,6 +690,12 @@ gfx::Size BrowserViewLayoutImplOld::GetMaximumDialogSize() const {
   // universally.
   views::View* view = views().contents_container;
   gfx::Rect content_area = view->ConvertRectToWidget(view->GetLocalBounds());
-  const int top = dialog_top_y_;
+  const int top = GetDialogTopY();
   return gfx::Size(content_area.width(), content_area.bottom() - top);
 }
+
+int BrowserViewLayoutImplOld::GetDialogTopY() const {
+  int dialog_top_y = dialog_top_y_;
+  delegate().UpdateDialogTopInsetInBrowserView(&dialog_top_y);
+  return dialog_top_y;
+}
diff --git chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.h chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.h
index b2200fccf65731c4af2b123963ecc4f5b534c5a4..bdc42b3c1385871f21d26339e3c3a4aea2435ce2 100644
--- chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.h
+++ chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.h
@@ -72,6 +72,8 @@ class BrowserViewLayoutImplOld : public BrowserViewLayout {
 
   bool IsImmersiveModeEnabledWithoutToolbar() const;
 
+  int GetDialogTopY() const;
+
   // Whether or not to use the browser based content minimum size.
   const bool use_browser_content_minimum_size_ = false;
 
diff --git chrome/browser/ui/views/frame/picture_in_picture_browser_frame_view.cc chrome/browser/ui/views/frame/picture_in_picture_browser_frame_view.cc
index 428908fe64734036bbe51a31623404e13393fad3..e1b87742be443603e24a0756f2d50ba91e7d9acc 100644
--- chrome/browser/ui/views/frame/picture_in_picture_browser_frame_view.cc
+++ chrome/browser/ui/views/frame/picture_in_picture_browser_frame_view.cc
@@ -718,6 +718,11 @@ PictureInPictureBrowserFrameView::PictureInPictureBrowserFrameView(
       IsOverlayViewVisible()) {
     PictureInPictureWindowManager::GetInstance()->ClearCachedBounds();
   }
+
+  if (!browser_view->browser()->SupportsWindowFeature(
+          Browser::WindowFeature::kFeatureTitleBar)) {
+    top_bar_container_view_->SetVisible(false);
+  }
 }
 
 PictureInPictureBrowserFrameView::~PictureInPictureBrowserFrameView() {
@@ -833,18 +838,42 @@ gfx::Rect PictureInPictureBrowserFrameView::GetWindowBoundsForClientBounds(
 
 int PictureInPictureBrowserFrameView::NonClientHitTest(
     const gfx::Point& point) {
-  // Allow interacting with the buttons.
-  if (GetLocationIconViewBounds().Contains(point) ||
-      GetBackToTabControlsBounds().Contains(point) ||
-      GetCloseControlsBounds().Contains(point)) {
-    return HTCLIENT;
+  const bool frameless = !top_bar_container_view_->GetVisible();
+  if (!frameless) {
+    // Allow interacting with the buttons.
+    if (GetLocationIconViewBounds().Contains(point) ||
+        GetBackToTabControlsBounds().Contains(point) ||
+        GetCloseControlsBounds().Contains(point)) {
+      return HTCLIENT;
+    }
+
+    for (size_t i = 0; i < content_setting_views_.size(); i++) {
+      if (GetContentSettingViewBounds(i).Contains(point)) {
+        return HTCLIENT;
+      }
+    }
   }
 
-  for (size_t i = 0; i < content_setting_views_.size(); i++) {
-    if (GetContentSettingViewBounds(i).Contains(point)) {
-      return HTCLIENT;
+#if BUILDFLAG(ENABLE_CEF)
+  if (frameless) {
+    // Match logic in BrowserView::ShouldDescendIntoChildForEventHandling.
+    const auto draggable_region =
+        GetBrowserView()->browser()->cef_delegate()->GetDraggableRegion();
+    if (draggable_region.has_value()) {
+      // Draggable regions are defined relative to the web contents.
+      gfx::Point point_in_contents_web_view_coords(point);
+      views::View::ConvertPointToTarget(GetWidget()->GetRootView(),
+                                        GetBrowserView()->contents_web_view(),
+                                        &point_in_contents_web_view_coords);
+
+      if (draggable_region->contains(
+              point_in_contents_web_view_coords.x(),
+              point_in_contents_web_view_coords.y())) {
+        return HTCAPTION;
+      }
     }
   }
+#endif  // BUILDFLAG(ENABLE_CEF)
 
   // Allow dragging and resizing the window.
   int window_component = GetHTComponentForFrame(
@@ -909,7 +938,8 @@ void PictureInPictureBrowserFrameView::Layout(PassKey) {
   gfx::Rect content_area = GetLocalBounds();
   content_area.Inset(FrameBorderInsets());
   gfx::Rect top_bar = content_area;
-  top_bar.set_height(kTopControlsHeight);
+  top_bar.set_height(
+      top_bar_container_view_->GetVisible() ? kTopControlsHeight : 0);
   top_bar_container_view_->SetBoundsRect(top_bar);
 #if !BUILDFLAG(IS_ANDROID)
   if (auto_pip_setting_overlay_) {
@@ -1489,7 +1519,8 @@ gfx::Insets PictureInPictureBrowserFrameView::FrameBorderInsets() const {
 }
 
 int PictureInPictureBrowserFrameView::GetTopAreaHeight() const {
-  return FrameBorderInsets().top() + kTopControlsHeight;
+  return FrameBorderInsets().top() +
+         (top_bar_container_view_->GetVisible() ? kTopControlsHeight : 0);
 }
 
 gfx::Size PictureInPictureBrowserFrameView::GetNonClientViewAreaSize() const {
diff --git chrome/browser/ui/views/frame/shadow_overlay_view.cc chrome/browser/ui/views/frame/shadow_overlay_view.cc
index 1713dcf489e01f35143ff4cc0d574cd64612fd97..b7cac9c6b3429fe2da329e481a1a2b0fce9b6aaf 100644
--- chrome/browser/ui/views/frame/shadow_overlay_view.cc
+++ chrome/browser/ui/views/frame/shadow_overlay_view.cc
@@ -220,6 +220,9 @@ void ShadowOverlayView::VisibilityChanged(View* starting_from, bool visible) {
 }
 
 void ShadowOverlayView::AddedToWidget() {
+  if (!browser_view_->toolbar_height_side_panel()) {
+    return;
+  }
   side_panel_observer_.Observe(browser_view_->toolbar_height_side_panel());
   side_panel_observer_.GetSource()->animation_coordinator()->AddObserver(
       kShadowOverlayOpacityAnimation, this);
diff --git chrome/browser/ui/views/omnibox/omnibox_popup_closer.cc chrome/browser/ui/views/omnibox/omnibox_popup_closer.cc
index a368273bdd56e49a8f998808a5ff3993ee0aca41..864aafe7084d769f494c10c7d4e2fe2b2780ed93 100644
--- chrome/browser/ui/views/omnibox/omnibox_popup_closer.cc
+++ chrome/browser/ui/views/omnibox/omnibox_popup_closer.cc
@@ -52,7 +52,8 @@ OmniboxPopupCloser::~OmniboxPopupCloser() = default;
 
 void OmniboxPopupCloser::OnMouseEvent(ui::MouseEvent* event) {
   // Close the omnibox popup if the click is outside the omnibox view.
-  if (!browser_view_->browser()->is_delete_scheduled() &&
+  if (browser_view_->browser() &&
+      !browser_view_->browser()->is_delete_scheduled() &&
       event->type() == ui::EventType::kMousePressed) {
     LocationBarView* location_bar_view = browser_view_->GetLocationBarView();
     CHECK(location_bar_view);
diff --git chrome/browser/ui/views/page_action/page_action_icon_controller.cc chrome/browser/ui/views/page_action/page_action_icon_controller.cc
index 796b619f0412cdc713ab33fed97af751e3390d7a..00fa5326bfc57e2feb5eb826484f5fcec2d7e197 100644
--- chrome/browser/ui/views/page_action/page_action_icon_controller.cc
+++ chrome/browser/ui/views/page_action/page_action_icon_controller.cc
@@ -109,6 +109,14 @@ void PageActionIconController::Init(const PageActionIconParams& params,
     if (IsPageActionMigrated(type)) {
       continue;
     }
+
+#if BUILDFLAG(ENABLE_CEF)
+    if (params.browser && params.browser->cef_delegate() &&
+        !params.browser->cef_delegate()->IsPageActionIconVisible(type)) {
+      continue;
+    }
+#endif
+
     switch (type) {
       case PageActionIconType::kPaymentsOfferNotification:
         add_page_action_icon(
diff --git chrome/browser/ui/views/toolbar/toolbar_view.cc chrome/browser/ui/views/toolbar/toolbar_view.cc
index cc4dfc5cf68a5d93b18ae5470dcebe22ad8d2deb..0d39443dfd94fc1ed6fb94d31b53883d9095bd3c 100644
--- chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -217,12 +217,14 @@ END_METADATA
 DEFINE_CLASS_ELEMENT_IDENTIFIER_VALUE(ToolbarView, kToolbarElementId);
 DEFINE_CLASS_ELEMENT_IDENTIFIER_VALUE(ToolbarView, kToolbarContainerElementId);
 
-ToolbarView::ToolbarView(Browser* browser, BrowserView* browser_view)
+ToolbarView::ToolbarView(Browser* browser,
+                         BrowserView* browser_view,
+                         std::optional<DisplayMode> display_mode)
     : AnimationDelegateViews(this),
       browser_(browser),
       browser_view_(browser_view),
       app_menu_icon_controller_(browser->profile(), this),
-      display_mode_(GetDisplayMode(browser)) {
+      display_mode_(display_mode ? *display_mode : GetDisplayMode(browser)) {
   SetID(VIEW_ID_TOOLBAR);
   SetProperty(views::kElementIdentifierKey, kToolbarElementId);
 
@@ -257,9 +259,24 @@ ToolbarView::~ToolbarView() {
   if (browser_view_->GetSupportsTabStrip()) {
     browser()->GetTabStripModel()->RemoveObserver(this);
   }
+
+  browser_view_->WillDestroyToolbar();
 }
 
 void ToolbarView::Init() {
+#if BUILDFLAG(ENABLE_CEF)
+  using ToolbarButtonType = cef::BrowserDelegate::ToolbarButtonType;
+  auto button_visible = [this](ToolbarButtonType type) {
+    if (this->browser_->cef_delegate()) {
+      return this->browser_->cef_delegate()->IsToolbarButtonVisible(type);
+    }
+    return true;
+  };
+#define BUTTON_VISIBLE(type) button_visible(ToolbarButtonType::type)
+#else
+#define BUTTON_VISIBLE(type) true
+#endif
+
 #if defined(USE_AURA)
   // Avoid generating too many occlusion tracking calculation events before this
   // function returns. The occlusion status will be computed only once once this
@@ -282,7 +299,7 @@ void ToolbarView::Init() {
 
   auto location_bar = std::make_unique<LocationBarView>(
       browser_, browser_->profile(), browser_->command_controller(), this,
-      display_mode_ != DisplayMode::kNormal);
+      display_mode_ != DisplayMode::kNormal && !browser_->toolbar_overridden());
   // Make sure the toolbar shows by default.
   size_animation_.Reset(1);
 
@@ -352,7 +369,8 @@ void ToolbarView::Init() {
   }
 
   std::unique_ptr<MediaToolbarButtonView> media_button;
-  if (base::FeatureList::IsEnabled(media::kGlobalMediaControls)) {
+  if (base::FeatureList::IsEnabled(media::kGlobalMediaControls) &&
+      BUTTON_VISIBLE(kMedia)) {
     media_button = std::make_unique<MediaToolbarButtonView>(
         browser_view_,
         std::make_unique<MediaToolbarButtonContextualMenu>(browser_));
@@ -410,7 +428,7 @@ void ToolbarView::Init() {
   pinned_toolbar_actions_container_ = container_view_->AddChildView(
       std::make_unique<PinnedToolbarActionsContainer>(browser_view_, this));
 
-  if (features::HasTabSearchToolbarButton()) {
+  if (features::HasTabSearchToolbarButton() && BUTTON_VISIBLE(kTabSearch)) {
     tab_search_button_ =
         pinned_toolbar_actions_container()->CreatePermanentButtonFor(
             kActionTabSearch);
@@ -439,7 +457,8 @@ void ToolbarView::Init() {
 
   // Only show the Battery Saver button when it is not controlled by the OS. On
   // ChromeOS the battery icon in the shelf shows the same information.
-  if (!performance_manager::user_tuning::IsBatterySaverModeManagedByOS()) {
+  if (!performance_manager::user_tuning::IsBatterySaverModeManagedByOS() &&
+      BUTTON_VISIBLE(kBatterySaver)) {
     battery_saver_button_ = container_view_->AddChildView(
         std::make_unique<BatterySaverButton>(browser_view_));
   }
@@ -468,7 +487,7 @@ void ToolbarView::Init() {
                                browser_->profile()->IsGuestSession() ||
                                browser_->profile()->IsRegularProfile();
 #endif
-  avatar_->SetVisible(show_avatar_toolbar_button);
+  avatar_->SetVisible(show_avatar_toolbar_button && BUTTON_VISIBLE(kAvatar));
 
 #if BUILDFLAG(ENABLE_WEBUI_TAB_STRIP)
   auto new_tab_button = std::make_unique<ToolbarButton>(base::BindRepeating(
@@ -826,9 +845,11 @@ void ToolbarView::Layout(PassKey) {
 
   if (display_mode_ == DisplayMode::kNormal) {
     LayoutCommon();
-    UpdateClipPath(
-        leading_corner_style != CornerStyle::kSquare ? corner_radius : 0,
-        trailing_corner_style != CornerStyle::kSquare ? corner_radius : 0);
+    if (!browser_->toolbar_overridden()) {
+      UpdateClipPath(
+          leading_corner_style != CornerStyle::kSquare ? corner_radius : 0,
+          trailing_corner_style != CornerStyle::kSquare ? corner_radius : 0);
+    }
   }
 
   if (toolbar_controller_) {
diff --git chrome/browser/ui/views/toolbar/toolbar_view.h chrome/browser/ui/views/toolbar/toolbar_view.h
index e7d7ec41980fd04f911e4b59ab172cd5f1d75166..2b4bbb9a2aaa727f67fe0a4a5515bebd8df284e2 100644
--- chrome/browser/ui/views/toolbar/toolbar_view.h
+++ chrome/browser/ui/views/toolbar/toolbar_view.h
@@ -90,7 +90,8 @@ class ToolbarView : public views::AccessiblePaneView,
   DECLARE_CLASS_ELEMENT_IDENTIFIER_VALUE(kToolbarElementId);
   DECLARE_CLASS_ELEMENT_IDENTIFIER_VALUE(kToolbarContainerElementId);
 
-  ToolbarView(Browser* browser, BrowserView* browser_view);
+  ToolbarView(Browser* browser, BrowserView* browser_view,
+              std::optional<DisplayMode> display_mode);
   ToolbarView(const ToolbarView&) = delete;
   ToolbarView& operator=(const ToolbarView&) = delete;
   ~ToolbarView() override;
