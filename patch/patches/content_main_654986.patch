diff --git base/process/set_process_title.cc base/process/set_process_title.cc
index aacd4a841f3940c27c5c73c03fa9bcc6e56448cc..f4488f8259836a8f3bb5c465df28ca40f2bdd455 100644
--- base/process/set_process_title.cc
+++ base/process/set_process_title.cc
@@ -54,9 +54,6 @@ void SetProcessTitleFromCommandLine(const char** main_argv) {
   bool have_argv0 = false;
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-  DCHECK_EQ(base::PlatformThread::CurrentId(),
-            base::PlatformThreadId(getpid()));
-
   if (main_argv) {
     setproctitle_init(main_argv);
   }
diff --git content/app/content_main.cc content/app/content_main.cc
index f2b1cdff827eae3726febe590f2f30b5f6d89046..cb18a6fe7c76483fe79abf64bbec8ad21f55fa57 100644
--- content/app/content_main.cc
+++ content/app/content_main.cc
@@ -202,16 +202,10 @@ ContentMainParams::~ContentMainParams() = default;
 ContentMainParams::ContentMainParams(ContentMainParams&&) = default;
 ContentMainParams& ContentMainParams::operator=(ContentMainParams&&) = default;
 
-// This function must be marked with NO_STACK_PROTECTOR or it may crash on
-// return, see the --change-stack-guard-on-fork command line flag.
-NO_STACK_PROTECTOR int RunContentProcess(
-    ContentMainParams params,
-    ContentMainRunner* content_main_runner) {
+int ContentMainInitialize(ContentMainParams params,
+                          ContentMainRunner* content_main_runner) {
   base::FeatureList::FailOnFeatureAccessWithoutFeatureList();
   int exit_code = -1;
-#if BUILDFLAG(IS_MAC)
-  base::apple::ScopedNSAutoreleasePool autorelease_pool;
-#endif
 
   // A flag to indicate whether Main() has been called before. On Android, we
   // may re-run Main() without restarting the browser process. This flag
@@ -290,7 +284,9 @@ NO_STACK_PROTECTOR int RunContentProcess(
     // default, "C", locale.
     setlocale(LC_NUMERIC, "C");
 
-    SetupSignalHandlers();
+    if (!params.disable_signal_handlers) {
+      SetupSignalHandlers();
+    }
 #endif
 
 #if BUILDFLAG(IS_WIN)
@@ -298,14 +294,6 @@ NO_STACK_PROTECTOR int RunContentProcess(
 #endif
 
 #if BUILDFLAG(IS_MAC)
-    // We need this pool for all the objects created before we get to the event
-    // loop, but we don't want to leave them hanging around until the app quits.
-    // Each "main" needs to flush this pool right before it goes into its main
-    // event loop to get rid of the cruft. TODO(crbug.com/40260311): This
-    // is not safe. Each main loop should create and destroy its own pool; it
-    // should not be flushing the pool at the base of the autorelease pool
-    // stack.
-    params.autorelease_pool = &autorelease_pool;
     InitializeMac();
 #endif
 
@@ -355,12 +343,44 @@ NO_STACK_PROTECTOR int RunContentProcess(
 
   if (IsSubprocess())
     CommonSubprocessInit();
-  exit_code = content_main_runner->Run();
 
+  return exit_code;
+}
+
+// This function must be marked with NO_STACK_PROTECTOR or it may crash on
+// return, see the --change-stack-guard-on-fork command line flag.
+NO_STACK_PROTECTOR int ContentMainRun(ContentMainRunner* content_main_runner) {
+  return content_main_runner->Run();
+}
+
+void ContentMainShutdown(ContentMainRunner* content_main_runner) {
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_IOS)
   content_main_runner->Shutdown();
 #endif
+}
+
+// This function must be marked with NO_STACK_PROTECTOR or it may crash on
+// return, see the --change-stack-guard-on-fork command line flag.
+NO_STACK_PROTECTOR int RunContentProcess(ContentMainParams params,
+                  ContentMainRunner* content_main_runner) {
+#if BUILDFLAG(IS_MAC)
+  // We need this pool for all the objects created before we get to the event
+  // loop, but we don't want to leave them hanging around until the app quits.
+  // Each "main" needs to flush this pool right before it goes into its main
+  // event loop to get rid of the cruft. TODO(https://crbug.com/1424190): This
+  // is not safe. Each main loop should create and destroy its own pool; it
+  // should not be flushing the pool at the base of the autorelease pool
+  // stack.
+  base::apple::ScopedNSAutoreleasePool autorelease_pool;
+  params.autorelease_pool = &autorelease_pool;
+#endif
+
+  int exit_code = ContentMainInitialize(std::move(params), content_main_runner);
+  if (exit_code >= 0)
+    return exit_code;
+  exit_code = ContentMainRun(content_main_runner);
 
+  ContentMainShutdown(content_main_runner);
   return exit_code;
 }
 
diff --git content/app/content_main_runner_impl.cc content/app/content_main_runner_impl.cc
index 81e2e8bbae7c2d8c5ef6c4fad5121121317901ca..eb95c8590b810dfbfee024110fc8a9779a30cc60 100644
--- content/app/content_main_runner_impl.cc
+++ content/app/content_main_runner_impl.cc
@@ -50,6 +50,7 @@
 #include "base/task/thread_pool/thread_pool_instance.h"
 #include "base/threading/hang_watcher.h"
 #include "base/threading/platform_thread.h"
+#include "base/threading/thread_restrictions.h"
 #include "base/time/default_clock.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
@@ -966,18 +967,12 @@ int ContentMainRunnerImpl::Initialize(ContentMainParams params) {
       }));
 
 #if !defined(OFFICIAL_BUILD) || BUILDFLAG(CHROME_FOR_TESTING)
-#if BUILDFLAG(IS_WIN)
-  bool should_enable_stack_dump = !process_type.empty();
-#else
-  bool should_enable_stack_dump = true;
-#endif
   // Print stack traces to stderr when crashes occur. This opens up security
   // holes so it should never be enabled for official builds. This needs to
   // happen before crash reporting is initialized (which for chrome happens in
   // the call to PreSandboxStartup() on the delegate below), because otherwise
   // this would interfere with signal handlers used by crash reporting.
-  if (should_enable_stack_dump &&
-      !command_line.HasSwitch(switches::kDisableInProcessStackTraces)) {
+  if (!command_line.HasSwitch(switches::kDisableInProcessStackTraces)) {
     base::debug::EnableInProcessStackDumping();
   }
 
@@ -1352,6 +1347,13 @@ void ContentMainRunnerImpl::Shutdown() {
   is_shutdown_ = true;
 }
 
+void ContentMainRunnerImpl::ShutdownOnUIThread() {
+  base::ScopedAllowBaseSyncPrimitivesForTesting allow_wait;
+  discardable_shared_memory_manager_.reset();
+  browser_memory_coordinator_.reset();
+  memory_pressure_listener_registry_.reset();
+}
+
 // static
 std::unique_ptr<ContentMainRunner> ContentMainRunner::Create() {
   return ContentMainRunnerImpl::Create();
diff --git content/app/content_main_runner_impl.h content/app/content_main_runner_impl.h
index e3d6621ec75a1b02c75fb0f4ad764339aea622f6..4ca2cc3de1fc428cfc0ff58865c81ed4a44597e0 100644
--- content/app/content_main_runner_impl.h
+++ content/app/content_main_runner_impl.h
@@ -31,7 +31,7 @@ namespace content {
 class BrowserMemoryCoordinator;
 class MojoIpcSupport;
 
-class ContentMainRunnerImpl : public ContentMainRunner {
+class CONTENT_EXPORT ContentMainRunnerImpl : public ContentMainRunner {
  public:
   static std::unique_ptr<ContentMainRunnerImpl> Create();
 
@@ -50,6 +50,8 @@ class ContentMainRunnerImpl : public ContentMainRunner {
   int Run() override;
   void Shutdown() override;
 
+  void ShutdownOnUIThread();
+
  private:
   int RunBrowser(MainFunctionParams main_function_params,
                  bool start_minimal_browser);
diff --git content/public/app/content_main.h content/public/app/content_main.h
index 7f9b51529735789778df928b06ac5e8f1c564a42..5606867e437806bc94a64aca0e61d21dfbd31a8d 100644
--- content/public/app/content_main.h
+++ content/public/app/content_main.h
@@ -66,6 +66,11 @@ struct CONTENT_EXPORT ContentMainParams {
   // are left uninitialized.
   bool minimal_browser_mode = false;
 
+#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_ANDROID)
+  // Indicates whether to disable signal handlers
+  bool disable_signal_handlers = false;
+#endif
+
 #if BUILDFLAG(IS_MAC)
   // The outermost autorelease pool to pass to main entry points.
   STACK_ALLOCATED_IGNORE("https://crbug.com/1424190")
@@ -94,6 +99,13 @@ struct CONTENT_EXPORT ContentMainParams {
   }
 };
 
+// Split RunContentProcess() into separate stages.
+CONTENT_EXPORT int ContentMainInitialize(
+    ContentMainParams params,
+    ContentMainRunner* content_main_runner);
+CONTENT_EXPORT int ContentMainRun(ContentMainRunner* content_main_runner);
+CONTENT_EXPORT void ContentMainShutdown(ContentMainRunner* content_main_runner);
+
 CONTENT_EXPORT int RunContentProcess(ContentMainParams params,
                                      ContentMainRunner* content_main_runner);
 
