// Copyright (c) 2008-2009 The Chromium Embedded Framework Authors.
// Portions copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "libcef/browser_webkit_glue.h"

#include "third_party/WebKit/Source/WebCore/config.h"
MSVC_PUSH_WARNING_LEVEL(0);
#include "ApplicationCacheStorage.h"  // NOLINT(build/include)
#include "CrossOriginPreflightResultCache.h"  // NOLINT(build/include)
#include "DocumentLoader.h"  // NOLINT(build/include)
#include "MemoryCache.h"  // NOLINT(build/include)
#include "TextEncoding.h"  // NOLINT(build/include)
#include "third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.h"
MSVC_POP_WARNING();
#undef LOG

#include "base/logging.h"
#include "base/string_util.h"
#include "net/base/mime_util.h"
#include "third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h"
#include "third_party/WebKit/Source/WebKit/chromium/public/WebView.h"
#include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebString.h"
#include "webkit/glue/user_agent.h"
#include "webkit/glue/webkit_glue.h"
#include "webkit/gpu/webgraphicscontext3d_in_process_command_buffer_impl.h"
#include "webkit/gpu/webgraphicscontext3d_in_process_impl.h"
#include "webkit/plugins/npapi/plugin_list.h"

// Generated by GRIT
#include "grit/webkit_resources.h"

using WebKit::WebFrameImpl;

namespace webkit_glue {

bool IsMediaPlayerAvailable() {
  return true;
}

void InitializeTextEncoding() {
  WebCore::UTF8Encoding();
}

v8::Handle<v8::Context> GetV8Context(WebKit::WebFrame* frame) {
  WebFrameImpl* webFrameImpl = static_cast<WebFrameImpl*>(frame);
  WebCore::Frame* core_frame = webFrameImpl->frame();
  return WebCore::V8Proxy::context(core_frame);
}

void ClearCache() {
  if (WebCore::memoryCache()->disabled())
    return;

  // Clear the memory cache by disabling and then re-enabling it.
  WebCore::memoryCache()->setDisabled(true);
  WebCore::memoryCache()->setDisabled(false);

  // Empty the Cross-Origin Preflight cache
  WebCore::CrossOriginPreflightResultCache::shared().empty();
}

#if defined(OS_LINUX)
int MatchFontWithFallback(const std::string& face, bool bold,
                          bool italic, int charset) {
  return -1;
}

bool GetFontTable(int fd, uint32_t table, uint8_t* output,
                  size_t* output_length) {
  return false;
}
#endif

// Adapted from Chromium's BufferedResourceHandler::ShouldDownload
bool ShouldDownload(const std::string& content_disposition,
                    const std::string& mime_type) {
  std::string type = StringToLowerASCII(mime_type);
  std::string disposition = StringToLowerASCII(content_disposition);

  // First, examine content-disposition.
  if (!disposition.empty()) {
    bool should_download = true;

    // Some broken sites just send ...
    //    Content-Disposition: ; filename="file"
    // ... screen those out here.
    if (disposition[0] == ';')
      should_download = false;

    if (disposition.compare(0, 6, "inline") == 0)
      should_download = false;

    // Some broken sites just send ...
    //    Content-Disposition: filename="file"
    // ... without a disposition token... Screen those out.
    if (disposition.compare(0, 8, "filename") == 0)
      should_download = false;

    // Also in use is Content-Disposition: name="file"
    if (disposition.compare(0, 4, "name") == 0)
      should_download = false;

    // We have a content-disposition of "attachment" or unknown.
    // RFC 2183, section 2.8 says that an unknown disposition
    // value should be treated as "attachment".
    if (should_download)
      return true;
  }

  // Mirrors WebViewImpl::CanShowMIMEType()
  if (type.empty() || net::IsSupportedMimeType(type))
    return false;

  // Finally, check the plugin list.
  bool allow_wildcard = false;
  std::vector<webkit::WebPluginInfo> plugins;
  webkit::npapi::PluginList::Singleton()->GetPluginInfoArray(
      GURL(), type, allow_wildcard, NULL, &plugins, NULL);

  // If any associated plugins exist and are enabled don't allow the download.
  if (!plugins.empty()) {
    std::vector<webkit::WebPluginInfo>::const_iterator it = plugins.begin();
    for (; it != plugins.end(); ++it) {
      if (webkit_glue::IsPluginEnabled(*it))
        return false;
    }
  }

  return true;
}

bool IsPluginEnabled(const webkit::WebPluginInfo& plugin) {
  return true;
}

WebKit::WebGraphicsContext3D* CreateGraphicsContext3D(
    cef_graphics_implementation_t graphics_implementation,
    const WebKit::WebGraphicsContext3D::Attributes& attributes,
    WebKit::WebView* web_view,
    bool renderDirectlyToWebView) {
#if defined(OS_WIN)
  bool use_command_buffer =
      (graphics_implementation == ANGLE_IN_PROCESS_COMMAND_BUFFER ||
       graphics_implementation == DESKTOP_IN_PROCESS_COMMAND_BUFFER);
#else
  bool use_command_buffer =
      (graphics_implementation == DESKTOP_IN_PROCESS_COMMAND_BUFFER);
#endif

  if (use_command_buffer) {
    WebKit::WebGraphicsContext3D* view_context = NULL;
    if (!renderDirectlyToWebView)
        view_context = web_view->graphicsContext3D();
    scoped_ptr<webkit::gpu::WebGraphicsContext3DInProcessCommandBufferImpl>
        context(
            new webkit::gpu::WebGraphicsContext3DInProcessCommandBufferImpl());
    if (!context->Initialize(attributes, view_context))
      return NULL;
    return context.release();
  } else {
    return webkit::gpu::WebGraphicsContext3DInProcessImpl::CreateForWebView(
        attributes, renderDirectlyToWebView);
  }
}

}  // namespace webkit_glue
